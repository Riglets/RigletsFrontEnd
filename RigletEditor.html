<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Riglet Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js" 
          onload="console.log('Lottie script loaded successfully');" 
          onerror="console.error('Failed to load Lottie script');"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--tg-theme-bg-color, #111);
      color: var(--tg-theme-text-color, #fff);
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    
    .header {
      padding: 12px 16px;
      text-align: center;
      border-bottom: 1px solid var(--tg-theme-hint-color, #333);
      background: var(--tg-theme-secondary-bg-color, #1a1a1a);
    }
    
    .header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    
    .preview-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: var(--tg-theme-bg-color, #111);
      min-height: 200px;
      position: relative;
    }
    
    .preview-placeholder {
      text-align: center;
      color: var(--tg-theme-hint-color, #888);
      font-size: 14px;
    }
    
    .preview-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    #lottieContainer {
      width: 100%;
      height: 100%;
      max-width: 300px;
      max-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #lottieContainer svg {
      max-width: 100%;
      max-height: 100%;
    }
    
    .tools-container {
      background: var(--tg-theme-secondary-bg-color, #1a1a1a);
      border-top: 1px solid var(--tg-theme-hint-color, #333);
      padding: 16px;
      overflow-y: auto;
      max-height: 50vh;
    }
    
    .tool-section {
      margin-bottom: 20px;
    }
    
    .tool-section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--tg-theme-hint-color, #aaa);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .color-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .color-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .color-label {
      min-width: 80px;
      font-size: 14px;
    }
    
    .color-input-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    input[type="color"] {
      width: 50px;
      height: 50px;
      border: 2px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      padding: 0;
      background: none;
      cursor: pointer;
    }
    
    .color-hex {
      font-family: monospace;
      font-size: 14px;
      padding: 8px 12px;
      background: var(--tg-theme-bg-color, #222);
      border: 1px solid var(--tg-theme-hint-color, #444);
      border-radius: 6px;
      color: var(--tg-theme-text-color, #fff);
      min-width: 80px;
      text-align: center;
    }
    
    .preset-colors {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    
    .preset-btn {
      aspect-ratio: 1;
      border: 2px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.1s;
    }
    
    .preset-btn:active {
      transform: scale(0.95);
    }
    
    .toggle-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--tg-theme-bg-color, #222);
      border-radius: 8px;
    }
    
    .toggle-label {
      font-size: 14px;
    }
    
    .toggle-switch {
      position: relative;
      width: 50px;
      height: 28px;
      background: var(--tg-theme-hint-color, #444);
      border-radius: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .toggle-switch.active {
      background: var(--tg-theme-button-color, #3390ec);
    }
    
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 24px;
      background: #fff;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
    }
    
    .toggle-switch.active::after {
      transform: translateX(22px);
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    button {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    button:active {
      opacity: 0.8;
    }
    
    .btn-preview {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
    }
    
    .btn-done {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
    }
    
    .btn-secondary {
      background: var(--tg-theme-secondary-bg-color, #2a2a2a);
      color: var(--tg-theme-text-color, #fff);
    }
    
    .limb-selector {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    
    .limb-btn {
      padding: 10px;
      background: var(--tg-theme-bg-color, #222);
      border: 1px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      color: var(--tg-theme-text-color, #fff);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .limb-btn.active {
      background: var(--tg-theme-button-color, #3390ec);
      border-color: var(--tg-theme-button-color, #3390ec);
    }
    
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="header">
    <h2>Riglet Editor</h2>
  </div>
  
  <div class="preview-container">
    <div class="preview-placeholder" id="previewPlaceholder">
      Loading Riglet preview...
    </div>
    <div id="lottieContainer" class="hidden"></div>
  </div>
  
  <div class="tools-container">
    <!-- Global Colors -->
    <div class="tool-section">
      <div class="tool-section-title">Global Colors</div>
      <div class="color-group">
        <div class="color-row">
          <span class="color-label">Fill:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalFill" value="#F1C799" />
            <input type="text" class="color-hex" id="globalFillHex" value="#F1C799" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stroke:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalStroke" value="#000000" />
            <input type="text" class="color-hex" id="globalStrokeHex" value="#000000" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stitch:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalStitch" value="#000000" />
            <input type="text" class="color-hex" id="globalStitchHex" value="#000000" maxlength="7" />
          </div>
        </div>
        <div class="preset-colors" id="presetColors"></div>
      </div>
    </div>
    
    <!-- Advanced Mode -->
    <div class="tool-section">
      <div class="tool-section-title">Advanced Coloring</div>
      <div class="limb-selector" id="limbSelector"></div>
      <div class="color-group hidden" id="advancedColors">
        <div class="color-row">
          <span class="color-label">Fill:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedFill" value="#F1C799" />
            <input type="text" class="color-hex" id="advancedFillHex" value="#F1C799" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stroke:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedStroke" value="#000000" />
            <input type="text" class="color-hex" id="advancedStrokeHex" value="#000000" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stitch:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedStitch" value="#000000" />
            <input type="text" class="color-hex" id="advancedStitchHex" value="#000000" maxlength="7" />
          </div>
        </div>
      </div>
    </div>
    
    <!-- Accessories -->
    <div class="tool-section">
      <div class="tool-section-title">Accessories</div>
      <div class="toggle-group" id="accessoriesGroup"></div>
    </div>
    
    <!-- Options -->
    <div class="tool-section">
      <div class="tool-section-title">Options</div>
      <div class="toggle-group">
        <div class="toggle-row">
          <span class="toggle-label">Stitch Style (Hashed)</span>
          <div class="toggle-switch active" id="stitchStyleToggle"></div>
        </div>
        <div class="toggle-row">
          <span class="toggle-label">Patch</span>
          <div class="toggle-switch" id="patchToggle"></div>
        </div>
      </div>
    </div>
    
    <!-- Actions -->
    <div class="button-group">
      <button class="btn-preview" id="previewBtn">Preview</button>
      <button class="btn-done" id="doneBtn">Done</button>
    </div>
  </div>

  <script>
    // Immediate test to see if script is running
    try {
      console.log("=== RIGLET EDITOR SCRIPT STARTING ===");
      console.log("Window loaded:", typeof window !== 'undefined');
      console.log("Document ready state:", document.readyState);
      
      const tg = window.Telegram.WebApp;
      console.log("Telegram WebApp object:", typeof tg !== 'undefined' ? 'available' : 'missing');
      
      if (tg) {
        tg.ready();
        tg.expand();
        console.log("Telegram WebApp initialized");
      } else {
        console.error("Telegram WebApp not available!");
      }
    } catch (e) {
      console.error("Error in initial script:", e);
      document.getElementById("previewPlaceholder").textContent = "Script error: " + e.message;
    }

    // Default state
    const state = {
      colors: {
        Head: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Left_Arm: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Right_Arm: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Left_Leg: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Right_Leg: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Body: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" }
      },
      stitch_hashed: true,
      use_patch: false,
      accessories: {
        Halo: false,
        Heart: false,
        Wings: false,
        CherryStem: false,
        Bow: false,
        Seeds: false
      },
      animation: "Default"
    };

    // Preset colors
    const presets = [
      { name: "Peach", hex: "#F1C799" },
      { name: "Tan", hex: "#C88C55" },
      { name: "Pink", hex: "#F49BC1" },
      { name: "Blue", hex: "#8FC7FF" },
      { name: "Mint", hex: "#A0FFD1" },
      { name: "White", hex: "#FFFFFF" },
      { name: "Black", hex: "#000000" }
    ];

    const limbs = ["Head", "Body", "Left_Arm", "Right_Arm", "Left_Leg", "Right_Leg"];
    const accessories = ["Halo", "Heart", "Wings", "CherryStem", "Bow", "Seeds"];

    // Riglet groups mapping (matches bot.py)
    const RIGLET_GROUPS = {
      "Head": {
        "fill": ["StrokeFill"],
        "stroke": ["Stroke", "StrokeFill"],
        "stitch": ["Stitch"],
      },
      "Left_Arm": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch"],
      },
      "Right_Arm": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch"],
      },
      "Left_Leg": {
        "fill": ["Fill", "StrokeFill"],
        "stroke": ["Stroke", "StrokeFill"],
        "stitch": ["Stitch"],
      },
      "Right_Leg": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch1", "Stitch2"],
      },
      "Body": {
        "fill": ["StrokeFill"],
        "stroke": ["StrokeFill"],
      },
    };

    const ACCESSORY_LAYERS = {
      "Halo": ["halofront", "haloback"],
      "Heart": ["Heart"],
      "Wings": ["Wings", "Wings 2"],
      "CherryStem": ["CherryStem"],
      "Bow": ["Bow"],
      "Seeds": ["Seeds"],
    };

    const STITCH_DASH_LENGTH = 10.0;

    let currentLimb = null;
    let isAdvancedMode = false;
    let baseAnimationData = null;
    let lottieInstance = null;
    let updateTimeout = null;

    // Initialize UI
    async function init() {
      console.log("=== INIT STARTING ===");
      console.log("Setting up UI components...");
      
      setupPresets();
      setupLimbSelector();
      setupAccessories();
      setupColorInputs();
      setupToggles();
      setupButtons();
      
      console.log("UI components set up");
      
      // Try to load initial state from initData if available
      if (tg.initDataUnsafe && tg.initDataUnsafe.start_param) {
        try {
          console.log("Loading saved state from initData...");
          const savedState = JSON.parse(decodeURIComponent(tg.initDataUnsafe.start_param));
          loadState(savedState);
        } catch (e) {
          console.log("No saved state found or error parsing:", e);
        }
      } else {
        console.log("No initData.start_param available");
      }
      
      // Load and render the animation
      console.log("Starting animation load...");
      await loadAndRenderAnimation();
      console.log("=== INIT COMPLETE ===");
    }

    function setupPresets() {
      const container = document.getElementById("presetColors");
      presets.forEach(preset => {
        const btn = document.createElement("button");
        btn.className = "preset-btn";
        btn.style.backgroundColor = preset.hex;
        btn.title = preset.name;
        btn.addEventListener("click", () => {
          if (isAdvancedMode && currentLimb) {
            applyColorToLimb(currentLimb, "fill", preset.hex);
          } else {
            applyGlobalColor("fill", preset.hex);
          }
        });
        container.appendChild(btn);
      });
    }

    function setupLimbSelector() {
      const container = document.getElementById("limbSelector");
      limbs.forEach(limb => {
        const btn = document.createElement("button");
        btn.className = "limb-btn";
        btn.textContent = limb.replace("_", " ");
        btn.addEventListener("click", () => {
          currentLimb = limb;
          isAdvancedMode = true;
          document.querySelectorAll(".limb-btn").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          document.getElementById("advancedColors").classList.remove("hidden");
          updateAdvancedColors();
        });
        container.appendChild(btn);
      });
    }

    function setupAccessories() {
      const container = document.getElementById("accessoriesGroup");
      accessories.forEach((acc, idx) => {
        const row = document.createElement("div");
        row.className = "toggle-row";
        
        const label = document.createElement("span");
        label.className = "toggle-label";
        label.textContent = acc;
        
        const toggle = document.createElement("div");
        toggle.className = "toggle-switch";
        if (state.accessories[acc]) {
          toggle.classList.add("active");
        }
        
        // Add event listener directly here
        toggle.addEventListener("click", () => {
          state.accessories[acc] = !state.accessories[acc];
          toggle.classList.toggle("active", state.accessories[acc]);
          updatePreview();
        });
        
        row.appendChild(label);
        row.appendChild(toggle);
        container.appendChild(row);
      });
    }

    function setupColorInputs() {
      // Global colors
      setupColorInput("globalFill", "globalFillHex", (val) => applyGlobalColor("fill", val));
      setupColorInput("globalStroke", "globalStrokeHex", (val) => applyGlobalColor("stroke", val));
      setupColorInput("globalStitch", "globalStitchHex", (val) => applyGlobalColor("stitch", val));
      
      // Advanced colors
      setupColorInput("advancedFill", "advancedFillHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "fill", val);
      });
      setupColorInput("advancedStroke", "advancedStrokeHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "stroke", val);
      });
      setupColorInput("advancedStitch", "advancedStitchHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "stitch", val);
      });
    }

    function setupColorInput(colorId, hexId, callback) {
      const colorInput = document.getElementById(colorId);
      const hexInput = document.getElementById(hexId);
      
      colorInput.addEventListener("input", (e) => {
        const val = e.target.value.toUpperCase();
        hexInput.value = val;
        callback(val);
      });
      
      colorInput.addEventListener("change", (e) => {
        const val = e.target.value.toUpperCase();
        hexInput.value = val;
        callback(val);
      });
      
      hexInput.addEventListener("input", (e) => {
        let val = e.target.value.toUpperCase();
        if (!val.startsWith("#")) val = "#" + val;
        if (/^#[0-9A-F]{6}$/.test(val)) {
          colorInput.value = val;
          callback(val);
        }
      });
      
      hexInput.addEventListener("blur", (e) => {
        let val = e.target.value.toUpperCase();
        if (!val.startsWith("#")) val = "#" + val;
        if (!/^#[0-9A-F]{6}$/.test(val)) {
          val = colorInput.value;
          hexInput.value = val;
        }
      });
    }

    function setupToggles() {
      const stitchToggle = document.getElementById("stitchStyleToggle");
      stitchToggle.addEventListener("click", () => {
        state.stitch_hashed = !state.stitch_hashed;
        stitchToggle.classList.toggle("active", state.stitch_hashed);
        updatePreview();
      });
      
      const patchToggle = document.getElementById("patchToggle");
      patchToggle.addEventListener("click", () => {
        state.use_patch = !state.use_patch;
        patchToggle.classList.toggle("active", state.use_patch);
        updatePreview();
      });
    }

    function setupButtons() {
      document.getElementById("previewBtn").addEventListener("click", () => {
        // Request preview from bot
        sendState("preview");
      });
      
      document.getElementById("doneBtn").addEventListener("click", () => {
        // Send final state and close
        sendState("done");
      });
    }

    function hexToRgba(hex) {
      hex = hex.replace("#", "");
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      return [r, g, b, 1];
    }

    function applyGlobalColor(kind, hex) {
      limbs.forEach(limb => {
        if (state.colors[limb][kind] !== undefined) {
          state.colors[limb][kind] = hex;
        }
      });
      updateGlobalColors();
      updatePreview();
    }

    function applyColorToLimb(limb, kind, hex) {
      if (state.colors[limb] && state.colors[limb][kind] !== undefined) {
        state.colors[limb][kind] = hex;
        updateAdvancedColors();
        updatePreview();
      }
    }

    function updateGlobalColors() {
      // Use first limb's colors as reference for global display
      const ref = state.colors.Head;
      document.getElementById("globalFill").value = ref.fill;
      document.getElementById("globalFillHex").value = ref.fill;
      document.getElementById("globalStroke").value = ref.stroke;
      document.getElementById("globalStrokeHex").value = ref.stroke;
      document.getElementById("globalStitch").value = ref.stitch;
      document.getElementById("globalStitchHex").value = ref.stitch;
    }

    function updateAdvancedColors() {
      if (!currentLimb) return;
      const colors = state.colors[currentLimb];
      document.getElementById("advancedFill").value = colors.fill || "#F1C799";
      document.getElementById("advancedFillHex").value = colors.fill || "#F1C799";
      document.getElementById("advancedStroke").value = colors.stroke || "#000000";
      document.getElementById("advancedStrokeHex").value = colors.stroke || "#000000";
      document.getElementById("advancedStitch").value = colors.stitch || "#000000";
      document.getElementById("advancedStitchHex").value = colors.stitch || "#000000";
    }

    function loadState(savedState) {
      if (savedState.colors) state.colors = savedState.colors;
      if (savedState.stitch_hashed !== undefined) state.stitch_hashed = savedState.stitch_hashed;
      if (savedState.use_patch !== undefined) state.use_patch = savedState.use_patch;
      if (savedState.accessories) state.accessories = savedState.accessories;
      if (savedState.animation) {
        state.animation = savedState.animation;
        // Reload animation if it changed
        if (baseAnimationData) {
          loadAndRenderAnimation();
        }
      }
      
      updateGlobalColors();
      document.getElementById("stitchStyleToggle").classList.toggle("active", state.stitch_hashed);
      document.getElementById("patchToggle").classList.toggle("active", state.use_patch);
      
      accessories.forEach((acc, idx) => {
        const toggle = document.querySelectorAll("#accessoriesGroup .toggle-switch")[idx];
        if (toggle) {
          toggle.classList.toggle("active", state.accessories[acc]);
        }
      });
      
      // Update preview if animation is already loaded
      if (baseAnimationData) {
        updatePreview();
      }
    }

    async function loadAndRenderAnimation() {
      try {
        // Check if lottie is loaded
        if (typeof lottie === 'undefined') {
          throw new Error("Lottie library not loaded");
        }
        
        const animationFile = state.animation === "Wave" ? "RigletBase.json" : "RigletTurn.json";
        const url = `https://riglets.github.io/RigletsFrontEnd/${animationFile}`;
        
        console.log("Loading animation from:", url);
        document.getElementById("previewPlaceholder").textContent = "Loading animation...";
        
        const response = await fetch(url);
        console.log("Response status:", response.status, response.statusText);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const contentType = response.headers.get("content-type");
        console.log("Content-Type:", contentType);
        
        if (!contentType || !contentType.includes("application/json")) {
          console.warn("Warning: Content-Type is not JSON:", contentType);
        }
        
        const jsonData = await response.json();
        console.log("Animation loaded successfully, layers:", jsonData.layers?.length || 0);
        
        baseAnimationData = jsonData;
        updatePreview();
      } catch (error) {
        console.error("Error loading animation:", error);
        const errorMsg = error.message || "Unknown error";
        document.getElementById("previewPlaceholder").textContent = 
          `Failed to load preview: ${errorMsg}. Check console for details.`;
        
        // Show more helpful error message
        if (errorMsg.includes("404") || errorMsg.includes("Not Found")) {
          document.getElementById("previewPlaceholder").textContent = 
            "File not found. Make sure RigletTurn.json and RigletBase.json are in your GitHub Pages repo and accessible at: https://riglets.github.io/RigletsFrontEnd/";
        } else if (errorMsg.includes("CORS") || errorMsg.includes("Failed to fetch")) {
          document.getElementById("previewPlaceholder").textContent = 
            "Network error. Check if GitHub Pages is enabled and files are accessible.";
        } else if (errorMsg.includes("JSON")) {
          document.getElementById("previewPlaceholder").textContent = 
            "Invalid JSON file. Make sure the JSON files are valid.";
        }
      }
    }

    function applyColorsToAnimation(data, colors, stitchHashed) {
      // Deep clone the data
      const animData = JSON.parse(JSON.stringify(data));
      
      // Apply colors
      for (const layer of animData.layers || []) {
        const layerName = layer.nm;
        if (!RIGLET_GROUPS[layerName]) continue;
        
        const limbDef = RIGLET_GROUPS[layerName];
        const colorDef = colors[layerName] || {};
        
        for (const shape of layer.shapes || []) {
          if (shape.ty !== "gr") continue;
          
          const groupName = shape.nm;
          const targets = [];
          
          if (limbDef.fill && limbDef.fill.includes(groupName)) {
            const fillColor = colorDef.fill;
            if (fillColor) targets.push({ kind: "fill", color: fillColor });
          }
          
          if (limbDef.stroke && limbDef.stroke.includes(groupName)) {
            const strokeColor = colorDef.stroke;
            if (strokeColor) targets.push({ kind: "stroke", color: strokeColor });
          }
          
          if (limbDef.stitch && limbDef.stitch.includes(groupName)) {
            const stitchColor = colorDef.stitch;
            if (stitchColor) targets.push({ kind: "stitch", color: stitchColor });
          }
          
          for (const target of targets) {
            const rgba = hexToRgba(target.color);
            
            for (const it of shape.it || []) {
              const ty = it.ty;
              
              if (ty === "fl" && target.kind === "fill") {
                if (it.c && it.c.k) {
                  it.c.k = rgba;
                }
              }
              
              if (ty === "st" && (target.kind === "stroke" || target.kind === "stitch")) {
                if (it.c && it.c.k) {
                  it.c.k = rgba;
                }
              
                if (target.kind === "stitch") {
                  if (stitchHashed) {
                    it.d = [
                      { n: "d", v: { a: 0, k: STITCH_DASH_LENGTH } },
                      { n: "o", v: { a: 0, k: 0 } }
                    ];
                  } else {
                    if (it.d) delete it.d;
                  }
                }
              }
            }
          }
        }
      }
      
      // Apply accessories visibility
      for (const layer of animData.layers || []) {
        const layerName = layer.nm;
        for (const [accName, layerNames] of Object.entries(ACCESSORY_LAYERS)) {
          if (layerNames.includes(layerName)) {
            layer.hd = !state.accessories[accName];
          }
        }
      }
      
      // Apply patch visibility - remove TGpatch from Left_Leg if patch is off
      for (const layer of animData.layers || []) {
        if (layer.nm === "Left_Leg" && layer.shapes) {
          layer.shapes = layer.shapes.filter(shape => {
            if (shape.nm === "TGpatch" && !state.use_patch) {
              return false; // Remove patch
            }
            return true; // Keep other shapes
          });
        }
      }
      
      return animData;
    }

    function updatePreview() {
      if (!baseAnimationData) {
        console.log("No animation data available yet");
        return;
      }
      
      // Check if lottie is loaded
      if (typeof lottie === 'undefined') {
        console.error("Lottie library not available");
        document.getElementById("previewPlaceholder").textContent = "Lottie library not loaded";
        document.getElementById("previewPlaceholder").classList.remove("hidden");
        document.getElementById("lottieContainer").classList.add("hidden");
        return;
      }
      
      // Debounce updates for performance
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }
      
      updateTimeout = setTimeout(() => {
        try {
          console.log("Applying colors to animation...");
          const coloredData = applyColorsToAnimation(
            baseAnimationData,
            state.colors,
            state.stitch_hashed
          );
          
          console.log("Animation data processed, layers:", coloredData.layers?.length);
          
          // Clear the container first
          const container = document.getElementById("lottieContainer");
          container.innerHTML = '';
          
          // Destroy existing instance
          if (lottieInstance) {
            try {
              lottieInstance.destroy();
            } catch (e) {
              console.warn("Error destroying previous instance:", e);
            }
            lottieInstance = null;
          }
          
          // Hide placeholder, show container
          document.getElementById("previewPlaceholder").classList.add("hidden");
          container.classList.remove("hidden");
          
          // Create new instance with updated data
          console.log("Rendering animation with Lottie...");
          lottieInstance = lottie.loadAnimation({
            container: container,
            renderer: "svg",
            loop: true,
            autoplay: true,
            animationData: coloredData
          });
          
          // Add event listeners to check if animation loaded
          lottieInstance.addEventListener('data_ready', () => {
            console.log("Lottie animation data ready");
          });
          
          lottieInstance.addEventListener('DOMLoaded', () => {
            console.log("Lottie animation DOM loaded");
          });
          
          lottieInstance.addEventListener('error', (error) => {
            console.error("Lottie animation error:", error);
            document.getElementById("previewPlaceholder").classList.remove("hidden");
            container.classList.add("hidden");
            document.getElementById("previewPlaceholder").textContent = 
              `Animation error: ${error.message || "Unknown error"}`;
          });
          
          console.log("Animation instance created");
        } catch (error) {
          console.error("Error updating preview:", error);
          document.getElementById("previewPlaceholder").classList.remove("hidden");
          document.getElementById("lottieContainer").classList.add("hidden");
          document.getElementById("previewPlaceholder").textContent = 
            `Error rendering preview: ${error.message}`;
        }
      }, 100); // 100ms debounce for smooth updates
    }

    function sendState(action) {
      const data = {
        action: action,
        colors: state.colors,
        stitch_hashed: state.stitch_hashed,
        use_patch: state.use_patch,
        accessories: state.accessories,
        animation: state.animation
      };
      
      tg.sendData(JSON.stringify(data));
      
      if (action === "done") {
        tg.close();
      }
    }

    // Wait for DOM and scripts to load
    function startApp() {
      console.log("Starting app initialization...");
      console.log("Lottie available:", typeof lottie !== 'undefined');
      console.log("Telegram WebApp available:", typeof tg !== 'undefined');
      
      if (typeof lottie === 'undefined') {
        console.warn("Lottie not loaded yet, waiting...");
        document.getElementById("previewPlaceholder").textContent = "Loading Lottie library...";
        
        // Check every 100ms for lottie
        const checkLottie = setInterval(() => {
          if (typeof lottie !== 'undefined') {
            clearInterval(checkLottie);
            console.log("Lottie loaded, initializing app...");
            init();
          }
        }, 100);
        
        // Give up after 5 seconds
        setTimeout(() => {
          if (typeof lottie === 'undefined') {
            clearInterval(checkLottie);
            console.error("Lottie library failed to load after 5 seconds");
            document.getElementById("previewPlaceholder").textContent = 
              "Failed to load Lottie library. Please check your internet connection.";
          }
        }, 5000);
      } else {
        console.log("Lottie already loaded, initializing immediately...");
        init();
      }
    }
    
    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', startApp);
    } else {
      // DOM already loaded
      startApp();
    }
    
    // Also try on window load as backup
    window.addEventListener('load', () => {
      if (!baseAnimationData && typeof lottie !== 'undefined') {
        console.log("Window loaded, checking if we need to initialize...");
        if (typeof baseAnimationData === 'undefined' || baseAnimationData === null) {
          console.log("Initializing from window load event...");
          init();
        }
      }
    });
  </script>
</body>
</html>

