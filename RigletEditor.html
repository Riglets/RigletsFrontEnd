<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Riglet Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js" 
          onload="console.log('Lottie script loaded successfully');" 
          onerror="console.error('Failed to load Lottie script');"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--tg-theme-bg-color, #111);
      color: var(--tg-theme-text-color, #fff);
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    
    .header {
      padding: 12px 16px;
      text-align: center;
      border-bottom: 1px solid var(--tg-theme-hint-color, #333);
      background: var(--tg-theme-secondary-bg-color, #1a1a1a);
    }
    
    .header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    
    .preview-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: var(--tg-theme-bg-color, #111);
      min-height: 180px;
      position: relative;
      overflow: hidden;
    }
    
    .preview-placeholder {
      text-align: center;
      color: var(--tg-theme-hint-color, #888);
      font-size: 14px;
    }
    
    .preview-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    #lottieContainer {
      width: 100%;
      height: 100%;
      max-width: 240px;
      max-height: 240px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    #lottieContainer svg {
      width: 100% !important;
      height: 100% !important;
      max-width: 240px !important;
      max-height: 240px !important;
      display: block !important;
      visibility: visible !important;
    }
    
    .tools-container {
      background: var(--tg-theme-secondary-bg-color, #1a1a1a);
      border-top: 1px solid var(--tg-theme-hint-color, #333);
      padding: 16px;
      overflow-y: auto;
      max-height: 50vh;
    }
    
    .tool-section {
      margin-bottom: 20px;
    }
    
    .tool-section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--tg-theme-hint-color, #aaa);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .color-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .color-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .color-label {
      min-width: 80px;
      font-size: 14px;
    }
    
    .color-input-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    input[type="color"] {
      width: 50px;
      height: 50px;
      border: 2px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      padding: 0;
      background: none;
      cursor: pointer;
    }
    
    .color-hex {
      font-family: monospace;
      font-size: 14px;
      padding: 8px 12px;
      background: var(--tg-theme-bg-color, #222);
      border: 1px solid var(--tg-theme-hint-color, #444);
      border-radius: 6px;
      color: var(--tg-theme-text-color, #fff);
      min-width: 80px;
      text-align: center;
    }
    
    
    .toggle-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--tg-theme-bg-color, #222);
      border-radius: 8px;
    }
    
    .toggle-label {
      font-size: 14px;
    }
    
    .toggle-switch {
      position: relative;
      width: 50px;
      height: 28px;
      background: var(--tg-theme-hint-color, #444);
      border-radius: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .toggle-switch.active {
      background: var(--tg-theme-button-color, #3390ec);
    }
    
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 24px;
      background: #fff;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
    }
    
    .toggle-switch.active::after {
      transform: translateX(22px);
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    button {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    button:active {
      opacity: 0.8;
    }
    
    .btn-preview {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
    }
    
    .btn-done {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
    }
    
    .btn-secondary {
      background: var(--tg-theme-secondary-bg-color, #2a2a2a);
      color: var(--tg-theme-text-color, #fff);
    }
    
    .btn-preset {
      background: var(--tg-theme-secondary-bg-color, #2a2a2a);
      color: var(--tg-theme-text-color, #fff);
      border: 2px solid transparent;
    }
    
    .btn-preset.active {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
      border-color: var(--tg-theme-button-color, #3390ec);
    }
    
    .limb-selector {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    
    .limb-btn {
      padding: 10px;
      background: var(--tg-theme-bg-color, #222);
      border: 1px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      color: var(--tg-theme-text-color, #fff);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .limb-btn.active {
      background: var(--tg-theme-button-color, #3390ec);
      border-color: var(--tg-theme-button-color, #3390ec);
    }
    
    .hidden {
      display: none;
    }
    
    /* Draw feature styles */
    .draw-controls {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    
    .btn-draw {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
      padding: 8px 12px;
      font-size: 12px;
    }
    
    .btn-edit-shape {
      background: var(--tg-theme-secondary-bg-color, #2a2a2a);
      color: var(--tg-theme-text-color, #fff);
      padding: 8px 12px;
      font-size: 12px;
    }
    
    .btn-reset-shape {
      background: var(--tg-theme-secondary-bg-color, #2a2a2a);
      color: var(--tg-theme-text-color, #fff);
      padding: 8px 12px;
      font-size: 12px;
    }
    
    .draw-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      display: none;
      flex-direction: column;
      padding: 16px;
    }
    
    .draw-modal:not(.hidden) {
      display: flex;
    }
    
    .draw-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      color: var(--tg-theme-text-color, #fff);
    }
    
    .draw-canvas-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--tg-theme-bg-color, #222);
      border-radius: 8px;
      padding: 16px;
      min-height: 0;
    }
    
    #drawCanvas {
      flex: 1;
      border: 2px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      background: #fff;
      cursor: crosshair;
      touch-action: none;
      max-width: 100%;
      max-height: 400px;
    }
    
    .draw-tools {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    
    .draw-tool-btn {
      padding: 8px 12px;
      background: var(--tg-theme-secondary-bg-color, #2a2a2a);
      color: var(--tg-theme-text-color, #fff);
      border: 1px solid var(--tg-theme-hint-color, #444);
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }
    
    .draw-tool-btn.active {
      background: var(--tg-theme-button-color, #3390ec);
      border-color: var(--tg-theme-button-color, #3390ec);
    }
    
    .draw-colors {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .draw-color-input {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .draw-color-input label {
      font-size: 12px;
      min-width: 50px;
    }
    
    .draw-color-input input[type="color"] {
      width: 40px;
      height: 40px;
    }
    
    .draw-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    
    .draw-actions button {
      flex: 1;
      padding: 12px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h2>Riglet Editor</h2>
  </div>
  
  <div class="preview-container">
    <div class="preview-placeholder" id="previewPlaceholder">
      Loading Riglet preview...
    </div>
    <div id="lottieContainer" class="hidden"></div>
  </div>
  
  <div class="tools-container">
    <!-- Global Colors -->
    <div class="tool-section">
      <div class="tool-section-title">Global Colors</div>
      <div class="color-group">
        <div class="color-row">
          <span class="color-label">Fill:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalFill" value="#F1C799" />
            <input type="text" class="color-hex" id="globalFillHex" value="#F1C799" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stroke:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalStroke" value="#000000" />
            <input type="text" class="color-hex" id="globalStrokeHex" value="#000000" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stitch:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalStitch" value="#000000" />
            <input type="text" class="color-hex" id="globalStitchHex" value="#000000" maxlength="7" />
        </div>
      </div>
    </div>
    </div>
    
    <!-- Advanced Mode -->
    <div class="tool-section">
      <div class="tool-section-title">Advanced Coloring</div>
      <div class="limb-selector" id="limbSelector"></div>
      <div class="color-group hidden" id="advancedColors">
        <div class="color-row">
          <span class="color-label">Fill:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedFill" value="#F1C799" />
            <input type="text" class="color-hex" id="advancedFillHex" value="#F1C799" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stroke:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedStroke" value="#000000" />
            <input type="text" class="color-hex" id="advancedStrokeHex" value="#000000" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stitch:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedStitch" value="#000000" />
            <input type="text" class="color-hex" id="advancedStitchHex" value="#000000" maxlength="7" />
          </div>
        </div>
      </div>
    </div>
    
    <!-- Accessories -->
    <div class="tool-section">
      <div class="tool-section-title">Accessories</div>
      <div class="toggle-group" id="accessoriesGroup"></div>
    </div>
    
    <!-- Draw Modal -->
    <div class="draw-modal hidden" id="drawModal">
      <div class="draw-header">
        <h3 style="margin: 0; font-size: 16px;">Draw Custom Shape</h3>
        <button class="btn-secondary" id="closeDrawModal" style="padding: 8px 16px; font-size: 14px;">‚úï Close</button>
      </div>
      <div class="draw-canvas-container">
        <div class="draw-tools">
          <button class="draw-tool-btn active" id="toolPen" data-tool="pen">‚úèÔ∏è Vector Pen</button>
          <button class="draw-tool-btn" id="toolClear" data-tool="clear">üóëÔ∏è Clear</button>
          <button class="draw-tool-btn" id="toolClosePath" data-tool="close">‚úì Close Path</button>
        </div>
        <div style="font-size: 11px; color: var(--tg-theme-hint-color, #888); margin-bottom: 8px; padding: 4px;">
          Click to place points. Lines connect automatically. Click "Close Path" when done.
        </div>
        <div class="draw-colors">
          <div class="draw-color-input">
            <label>Fill:</label>
            <input type="color" id="drawFillColor" value="#FF0000" />
            <input type="text" class="color-hex" id="drawFillHex" value="#FF0000" maxlength="7" style="min-width: 70px; font-size: 12px; padding: 6px;" />
          </div>
          <div class="draw-color-input">
            <label>Stroke:</label>
            <input type="color" id="drawStrokeColor" value="#000000" />
            <input type="text" class="color-hex" id="drawStrokeHex" value="#000000" maxlength="7" style="min-width: 70px; font-size: 12px; padding: 6px;" />
          </div>
        </div>
        <canvas id="drawCanvas" width="300" height="300"></canvas>
        <div class="draw-actions">
          <button class="btn-secondary" id="cancelDraw">Cancel</button>
          <button class="btn-done" id="saveDraw">Save Shape</button>
        </div>
      </div>
    </div>
    
    <!-- Options -->
    <div class="tool-section">
      <div class="tool-section-title">Options</div>
      <div class="toggle-group">
        <div class="toggle-row">
          <span class="toggle-label">Stitch Style (Hashed)</span>
          <div class="toggle-switch active" id="stitchStyleToggle"></div>
        </div>
      </div>
      <div class="tool-section-title" style="margin-top: 16px;">Animation</div>
      <div class="button-group" style="flex-direction: column; gap: 8px;">
        <button class="btn-preset" id="animDefault">Default</button>
        <button class="btn-preset" id="animWave">Wave</button>
      </div>
    </div>
    
    <!-- Actions -->
    <div class="button-group">
      <button class="btn-preview" id="previewBtn">Preview</button>
      <button class="btn-done" id="doneBtn">Done</button>
    </div>
  </div>

  <script>
    // Define tg in global scope so all functions can access it
    let tg = null;
    
    // Initialize Telegram WebApp immediately
    try {
      console.log("=== RIGLET EDITOR SCRIPT STARTING ===");
      console.log("Window loaded:", typeof window !== 'undefined');
      console.log("Document ready state:", document.readyState);
      
      if (typeof window !== 'undefined' && window.Telegram && window.Telegram.WebApp) {
        tg = window.Telegram.WebApp;
        console.log("Telegram WebApp object: available");
        
        if (tg) {
    tg.ready();
    tg.expand();
          console.log("Telegram WebApp initialized");
        }
      } else {
        console.log("Telegram WebApp not available (running outside Telegram)");
      }
    } catch (e) {
      console.error("Error in initial script:", e);
      const placeholder = document.getElementById("previewPlaceholder");
      if (placeholder) {
        placeholder.textContent = "Script error: " + e.message;
      }
    }

    // Default state
    const state = {
      colors: {
        Head: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Left_Arm: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Right_Arm: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Left_Leg: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Right_Leg: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Body: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" }
      },
      stitch_hashed: true,
      accessories: {
        Halo: false,
        Heart: false,
        Wings: false,
        CherryStem: false,
        Bow: false,
        Seeds: false,
        TGpatch: false
      },
      animation: "Default",
      customShapes: {} // Store custom drawn shapes: { "Heart": { path: "...", fill: "#...", stroke: "#..." } }
    };


    const limbs = ["Head", "Body", "Left_Arm", "Right_Arm", "Left_Leg", "Right_Leg"];
    const accessories = ["Halo", "Heart", "Wings", "CherryStem", "Bow", "Seeds", "TGpatch"];

    // Riglet groups mapping (matches bot.py)
    const RIGLET_GROUPS = {
      "Head": {
        "fill": ["StrokeFill"],
        "stroke": ["Stroke", "StrokeFill"],
        "stitch": ["Stitch"],
      },
      "Left_Arm": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch"],
      },
      "Right_Arm": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch"],
      },
      "Left_Leg": {
        "fill": ["Fill", "StrokeFill"],
        "stroke": ["Stroke", "StrokeFill"],
        "stitch": ["Stitch"],
      },
      "Right_Leg": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch1", "Stitch2"],
      },
      "Body": {
        "fill": ["StrokeFill"],
        "stroke": ["StrokeFill"],
      },
    };

    const ACCESSORY_LAYERS = {
      "Halo": ["halofront", "haloback"],
      "Heart": ["Heart", "CustomHeart"], // CustomHeart is used for custom drawn shapes
      "Wings": ["Wings", "Wings 2"],
      "CherryStem": ["CherryStem"],
      "Bow": ["Bow"],
      "Seeds": ["Seeds"],
    };

    const STITCH_DASH_LENGTH = 10.0;

    let currentLimb = null;
    let isAdvancedMode = false;
    let baseAnimationData = null;
    let lottieInstance = null;
    let updateTimeout = null;
    let isInitialized = false; // Prevent duplicate initialization

    // Initialize UI
    async function init() {
      // Prevent duplicate initialization
      if (isInitialized) {
        console.log("Already initialized, skipping...");
        return;
      }
      isInitialized = true;
      
      console.log("=== INIT STARTING ===");
      console.log("Setting up UI components...");
      
      // Ensure draw modal is hidden on init
      const drawModal = document.getElementById("drawModal");
      if (drawModal) {
        drawModal.classList.add("hidden");
      }
      
      setupLimbSelector();
      setupAccessories();
      setupColorInputs();
      setupToggles();
      setupButtons();
      
      console.log("UI components set up");
      
      // Try to load initial state from initData if available
      if (tg && tg.initDataUnsafe && tg.initDataUnsafe.start_param) {
        try {
          console.log("Loading saved state from initData...");
          const savedState = JSON.parse(decodeURIComponent(tg.initDataUnsafe.start_param));
          loadState(savedState);
        } catch (e) {
          console.log("No saved state found or error parsing:", e);
        }
      } else {
        console.log("No initData.start_param available");
      }
      
      // Load and render the animation
      console.log("Starting animation load...");
      await loadAndRenderAnimation();
      console.log("=== INIT COMPLETE ===");
    }


    function setupLimbSelector() {
      const container = document.getElementById("limbSelector");
      limbs.forEach(limb => {
        const btn = document.createElement("button");
        btn.className = "limb-btn";
        btn.textContent = limb.replace("_", " ");
        btn.addEventListener("click", () => {
          currentLimb = limb;
          isAdvancedMode = true;
          document.querySelectorAll(".limb-btn").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          document.getElementById("advancedColors").classList.remove("hidden");
          updateAdvancedColors();
        });
        container.appendChild(btn);
      });
    }

    function setupAccessories() {
      const container = document.getElementById("accessoriesGroup");
      accessories.forEach((acc, idx) => {
        const row = document.createElement("div");
        row.className = "toggle-row";
        
        const label = document.createElement("span");
        label.className = "toggle-label";
        label.textContent = acc;
        
        const rightSide = document.createElement("div");
        rightSide.style.display = "flex";
        rightSide.style.alignItems = "center";
        rightSide.style.gap = "8px";
        
        const toggle = document.createElement("div");
        toggle.className = "toggle-switch";
        if (state.accessories[acc]) {
          toggle.classList.add("active");
        }
        
        // Add event listener directly here
        toggle.addEventListener("click", () => {
          state.accessories[acc] = !state.accessories[acc];
          toggle.classList.toggle("active", state.accessories[acc]);
          updatePreview();
        });
        
        rightSide.appendChild(toggle);
        
        // Add Draw button for Heart accessory
        if (acc === "Heart") {
          const drawBtn = document.createElement("button");
          drawBtn.className = "btn-draw";
          drawBtn.textContent = "Draw";
          drawBtn.style.padding = "6px 10px";
          drawBtn.style.fontSize = "11px";
          drawBtn.addEventListener("click", () => {
            openDrawModal("Heart");
          });
          rightSide.appendChild(drawBtn);
          
          // Add Reset button if custom shape exists
          if (state.customShapes && state.customShapes["Heart"]) {
            const resetBtn = document.createElement("button");
            resetBtn.className = "btn-reset-shape";
            resetBtn.textContent = "Reset";
            resetBtn.style.padding = "6px 10px";
            resetBtn.style.fontSize = "11px";
            resetBtn.addEventListener("click", () => {
              resetCustomShape("Heart");
            });
            rightSide.appendChild(resetBtn);
            
            // Add Edit button if custom shape exists
            const editBtn = document.createElement("button");
            editBtn.className = "btn-edit-shape";
            editBtn.textContent = "Edit";
            editBtn.style.padding = "6px 10px";
            editBtn.style.fontSize = "11px";
            editBtn.addEventListener("click", () => {
              openDrawModal("Heart", true);
            });
            rightSide.appendChild(editBtn);
          }
        }
        
        row.appendChild(label);
        row.appendChild(rightSide);
        container.appendChild(row);
      });
    }

    function setupColorInputs() {
      // Global colors
      setupColorInput("globalFill", "globalFillHex", (val) => applyGlobalColor("fill", val));
      setupColorInput("globalStroke", "globalStrokeHex", (val) => applyGlobalColor("stroke", val));
      setupColorInput("globalStitch", "globalStitchHex", (val) => applyGlobalColor("stitch", val));
      
      // Advanced colors
      setupColorInput("advancedFill", "advancedFillHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "fill", val);
      });
      setupColorInput("advancedStroke", "advancedStrokeHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "stroke", val);
      });
      setupColorInput("advancedStitch", "advancedStitchHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "stitch", val);
      });
    }

    function setupColorInput(colorId, hexId, callback) {
      const colorInput = document.getElementById(colorId);
      const hexInput = document.getElementById(hexId);
      
      colorInput.addEventListener("input", (e) => {
        const val = e.target.value.toUpperCase();
        hexInput.value = val;
        callback(val);
      });
      
      colorInput.addEventListener("change", (e) => {
        const val = e.target.value.toUpperCase();
        hexInput.value = val;
        callback(val);
      });
      
      hexInput.addEventListener("input", (e) => {
        let val = e.target.value.toUpperCase();
        if (!val.startsWith("#")) val = "#" + val;
        if (/^#[0-9A-F]{6}$/.test(val)) {
          colorInput.value = val;
          callback(val);
        }
      });
      
      hexInput.addEventListener("blur", (e) => {
        let val = e.target.value.toUpperCase();
        if (!val.startsWith("#")) val = "#" + val;
        if (!/^#[0-9A-F]{6}$/.test(val)) {
          val = colorInput.value;
          hexInput.value = val;
        }
      });
    }

    function setupToggles() {
      const stitchToggle = document.getElementById("stitchStyleToggle");
      stitchToggle.addEventListener("click", () => {
        state.stitch_hashed = !state.stitch_hashed;
        stitchToggle.classList.toggle("active", state.stitch_hashed);
        updatePreview();
      });
      
      // Animation selection
      const animDefault = document.getElementById("animDefault");
      const animWave = document.getElementById("animWave");
      
      function updateAnimationButtons() {
        animDefault.classList.toggle("active", state.animation === "Default");
        animWave.classList.toggle("active", state.animation === "Wave");
      }
      
      animDefault.addEventListener("click", () => {
        if (state.animation !== "Default") {
          state.animation = "Default";
          updateAnimationButtons();
          loadAndRenderAnimation();
        }
      });
      
      animWave.addEventListener("click", () => {
        if (state.animation !== "Wave") {
          state.animation = "Wave";
          updateAnimationButtons();
          loadAndRenderAnimation();
        }
      });
      
      updateAnimationButtons();
    }

    function setupButtons() {
      document.getElementById("previewBtn").addEventListener("click", () => {
        // Request preview from bot
        sendState("preview");
      });
      
      document.getElementById("doneBtn").addEventListener("click", () => {
        // Send final state and close
        sendState("done");
      });
      
      // Draw modal buttons
      setupDrawModal();
    }
    
    // Vector Pen Tool functionality
    let drawCanvas = null;
    let drawCtx = null;
    let vectorPoints = []; // Array of {x, y} points
    let isPathClosed = false;
    let hoverPoint = null; // For showing hover state
    let selectedPointIndex = -1; // For editing points
    let currentShapeName = null;
    let isEditMode = false;
    const POINT_RADIUS = 5; // Visual size of points
    const POINT_HIT_RADIUS = 8; // Hit detection radius
    
    function setupDrawModal() {
      drawCanvas = document.getElementById("drawCanvas");
      if (!drawCanvas) {
        console.warn("Draw canvas not found");
        return;
      }
      
      drawCtx = drawCanvas.getContext("2d");
      if (!drawCtx) {
        console.warn("Could not get canvas context");
        return;
      }
      
      // Set canvas size - use fixed size for consistency
      const maxSize = 300;
      drawCanvas.width = maxSize;
      drawCanvas.height = maxSize;
      
      // Initialize white background
      drawCtx.fillStyle = "#FFFFFF";
      drawCtx.fillRect(0, 0, maxSize, maxSize);
      
      // Tool buttons
      const toolButtons = document.querySelectorAll(".draw-tool-btn");
      if (toolButtons.length > 0) {
        toolButtons.forEach(btn => {
          btn.addEventListener("click", () => {
            if (btn.dataset.tool === "clear") {
              clearCanvas();
              return;
            }
            if (btn.dataset.tool === "close") {
              closePath();
              return;
            }
            document.querySelectorAll(".draw-tool-btn").forEach(b => b.classList.remove("active"));
            btn.classList.add("active");
          });
        });
      }
      
      // Color inputs
      setupColorInput("drawFillColor", "drawFillHex", (val) => {
        redrawVectorPath();
      });
      setupColorInput("drawStrokeColor", "drawStrokeHex", (val) => {
        redrawVectorPath();
      });
      
      // Vector pen tool - click to place points
      drawCanvas.addEventListener("click", handleCanvasClick);
      drawCanvas.addEventListener("mousemove", handleCanvasHover);
      drawCanvas.style.cursor = "crosshair";
      
      // Touch events for mobile
      drawCanvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        handleCanvasClick(e);
      });
      
      // Modal controls - check if elements exist
      const closeBtn = document.getElementById("closeDrawModal");
      const cancelBtn = document.getElementById("cancelDraw");
      const saveBtn = document.getElementById("saveDraw");
      
      if (closeBtn) {
        closeBtn.addEventListener("click", closeDrawModal);
      } else {
        console.warn("Close draw modal button not found");
      }
      
      if (cancelBtn) {
        cancelBtn.addEventListener("click", closeDrawModal);
      } else {
        console.warn("Cancel draw button not found");
      }
      
      if (saveBtn) {
        saveBtn.addEventListener("click", saveDrawnShape);
      } else {
        console.warn("Save draw button not found");
      }
    }
    
    function openDrawModal(shapeName, editMode = false) {
      currentShapeName = shapeName;
      isEditMode = editMode;
      const modal = document.getElementById("drawModal");
      if (modal) {
        modal.classList.remove("hidden");
      } else {
        console.error("Draw modal not found");
        return;
      }
      
      clearCanvas();
      
      // If editing, load existing shape
      if (editMode && state.customShapes && state.customShapes[shapeName]) {
        const shape = state.customShapes[shapeName];
        document.getElementById("drawFillColor").value = shape.fill || "#FF0000";
        document.getElementById("drawFillHex").value = shape.fill || "#FF0000";
        document.getElementById("drawStrokeColor").value = shape.stroke || "#000000";
        document.getElementById("drawStrokeHex").value = shape.stroke || "#000000";
        
        // Redraw the path if we have it
        if (shape.pathData) {
          redrawPathFromData(shape.pathData);
        }
      } else {
        // Reset to defaults
        document.getElementById("drawFillColor").value = "#FF0000";
        document.getElementById("drawFillHex").value = "#FF0000";
        document.getElementById("drawStrokeColor").value = "#000000";
        document.getElementById("drawStrokeHex").value = "#000000";
      }
    }
    
    function closeDrawModal() {
      const modal = document.getElementById("drawModal");
      if (modal) {
        modal.classList.add("hidden");
      }
      currentShapeName = null;
      isEditMode = false;
      vectorPoints = [];
      isPathClosed = false;
      hoverPoint = null;
      selectedPointIndex = -1;
    }
    
    function resetCustomShape(shapeName) {
      if (!state.customShapes) {
        state.customShapes = {};
      }
      
      // Remove the custom shape
      if (state.customShapes[shapeName]) {
        delete state.customShapes[shapeName];
        console.log("Reset custom shape for", shapeName);
        
        // Refresh accessories UI to remove Reset and Edit buttons
        const container = document.getElementById("accessoriesGroup");
        container.innerHTML = "";
        setupAccessories();
        
        // Update preview to show original shape
        updatePreview();
      }
    }
    
    function clearCanvas() {
      if (!drawCtx) return;
      vectorPoints = [];
      isPathClosed = false;
      hoverPoint = null;
      selectedPointIndex = -1;
      redrawVectorPath();
    }
    
    function closePath() {
      if (vectorPoints.length >= 3) {
        isPathClosed = true;
        redrawVectorPath();
      } else {
        alert("Need at least 3 points to close the path!");
      }
    }
    
    function getCanvasCoordinates(e) {
      if (!drawCanvas) return { x: 0, y: 0 };
      
      const rect = drawCanvas.getBoundingClientRect();
      const canvasWidth = drawCanvas.width;
      const canvasHeight = drawCanvas.height;
      const displayWidth = rect.width;
      const displayHeight = rect.height;
      
      // Calculate scale factors
      const scaleX = canvasWidth / displayWidth;
      const scaleY = canvasHeight / displayHeight;
      
      let clientX, clientY;
      
      if (e.offsetX !== undefined && e.offsetY !== undefined) {
        // Mouse event with offsetX/Y (most accurate)
        clientX = e.offsetX;
        clientY = e.offsetY;
      } else if (e.touches && e.touches.length > 0) {
        // Touch event
        clientX = e.touches[0].clientX - rect.left;
        clientY = e.touches[0].clientY - rect.top;
      } else if (e.clientX !== undefined && e.clientY !== undefined) {
        // Mouse event without offsetX/Y
        clientX = e.clientX - rect.left;
        clientY = e.clientY - rect.top;
      } else {
        return { x: 0, y: 0 };
      }
      
      // Scale to canvas coordinates
      const x = clientX * scaleX;
      const y = clientY * scaleY;
      
      return { x, y };
    }
    
    function handleCanvasClick(e) {
      if (!drawCtx || !drawCanvas) return;
      
      const coords = getCanvasCoordinates(e);
      const x = coords.x;
      const y = coords.y;
      
      // Check if clicking on existing point (for editing)
      const clickedPointIndex = findPointAt(x, y);
      
      if (clickedPointIndex >= 0) {
        // Clicked on existing point - could allow dragging in future
        selectedPointIndex = clickedPointIndex;
      } else {
        // Add new point
        vectorPoints.push({ x, y });
        isPathClosed = false; // Reset closed state when adding points
        selectedPointIndex = -1;
      }
      
      redrawVectorPath();
    }
    
    function handleCanvasHover(e) {
      if (!drawCtx || !drawCanvas) return;
      
      const coords = getCanvasCoordinates(e);
      const x = coords.x;
      const y = coords.y;
      
      const pointIndex = findPointAt(x, y);
      hoverPoint = pointIndex >= 0 ? pointIndex : null;
      
      redrawVectorPath();
    }
    
    function findPointAt(x, y) {
      for (let i = 0; i < vectorPoints.length; i++) {
        const point = vectorPoints[i];
        const dx = x - point.x;
        const dy = y - point.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= POINT_HIT_RADIUS) {
          return i;
        }
      }
      return -1;
    }
    
    function redrawVectorPath() {
      if (!drawCtx || !drawCanvas) return;
      
      // Clear canvas
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      drawCtx.fillStyle = "#FFFFFF";
      drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
      
      if (vectorPoints.length === 0) return;
      
      const fillColorInput = document.getElementById("drawFillColor");
      const strokeColorInput = document.getElementById("drawStrokeColor");
      const fillColor = fillColorInput ? fillColorInput.value : "#FF0000";
      const strokeColor = strokeColorInput ? strokeColorInput.value : "#000000";
      
      // Draw the path
      if (vectorPoints.length >= 2) {
        drawCtx.beginPath();
        drawCtx.moveTo(vectorPoints[0].x, vectorPoints[0].y);
        
        for (let i = 1; i < vectorPoints.length; i++) {
          drawCtx.lineTo(vectorPoints[i].x, vectorPoints[i].y);
        }
        
        // Close path if requested and we have enough points
        if (isPathClosed && vectorPoints.length >= 3) {
          drawCtx.closePath();
          
          // Fill the shape
          drawCtx.fillStyle = fillColor;
          drawCtx.fill();
        }
        
        // Draw stroke
        drawCtx.strokeStyle = strokeColor;
        drawCtx.lineWidth = 2;
        drawCtx.lineCap = "round";
        drawCtx.lineJoin = "round";
        drawCtx.stroke();
      }
      
      // Draw points
      vectorPoints.forEach((point, index) => {
        drawCtx.beginPath();
        drawCtx.arc(point.x, point.y, POINT_RADIUS, 0, Math.PI * 2);
        
        // Highlight hovered or selected point
        if (index === hoverPoint || index === selectedPointIndex) {
          drawCtx.fillStyle = "#3390ec";
          drawCtx.fill();
          drawCtx.strokeStyle = "#fff";
          drawCtx.lineWidth = 2;
          drawCtx.stroke();
        } else {
          drawCtx.fillStyle = strokeColor;
          drawCtx.fill();
          drawCtx.strokeStyle = "#fff";
          drawCtx.lineWidth = 1;
          drawCtx.stroke();
        }
      });
      
      // Draw preview line to mouse if path not closed
      if (!isPathClosed && vectorPoints.length > 0 && hoverPoint === null) {
        // This would require tracking mouse position, but for now we'll skip it
        // to keep it simple
      }
    }
    
    function redrawPathFromData(pathData) {
      // This would redraw a saved path - for now we'll just clear and let user redraw
      // In a full implementation, you'd parse the SVG path and redraw it
      clearCanvas();
    }
    
    
    function applyCustomShapeToLayer(layer, customShape) {
      // Find the shape group and path element
      // CustomHeart layer structure can be:
      // Option 1: layer -> shapes[] -> shape group -> it[] -> path/fill/stroke elements
      // Option 2: layer -> shapes[] -> direct path/fill/stroke elements (no group)
      // Looking for: Path 1 (sh), Fill 1 (fl), Stroke 1 (st)
      if (!layer.shapes || !Array.isArray(layer.shapes)) {
        console.warn("Layer", layer.nm, "has no shapes array");
        return;
      }
      
      console.log("Applying custom shape to layer:", layer.nm, "shapes:", layer.shapes.length);
      let pathFound = false;
      let fillFound = false;
      let strokeFound = false;
      
      // First, check if shapes are directly in layer.shapes (no group)
      const directShapes = layer.shapes.filter(s => s.ty === "sh" || s.ty === "fl" || s.ty === "st");
      if (directShapes.length > 0) {
        console.log("Found direct shapes (no group), processing:", directShapes.length);
        for (const shape of directShapes) {
          if (!shape || !shape.ty) continue;
          
          // Look for "Path 1", "Fill 1", "Stroke 1" by name or type
          const itemName = shape.nm || "";
          const isPath1 = shape.ty === "sh" && (itemName === "Path 1" || itemName.includes("Path") || !itemName);
          const isFill1 = shape.ty === "fl" && (itemName === "Fill 1" || itemName.includes("Fill") || !itemName);
          const isStroke1 = shape.ty === "st" && (itemName === "Stroke 1" || itemName.includes("Stroke") || !itemName);
          
          if (isPath1) {
            pathFound = true;
            // Store original path for reference (to get position/scale)
            const originalPath = shape.ks;
            console.log("Found path element (sh) -", itemName || "unnamed", "original path:", originalPath ? "exists" : "missing");
            if (originalPath && originalPath.k && originalPath.k.v) {
              console.log("Original path has", originalPath.k.v.length, "vertices");
              if (originalPath.k.v.length > 0) {
                console.log("Original first vertex:", originalPath.k.v[0]);
              }
            }
            
            // Convert SVG path to Lottie path format
            const lottiePath = convertSVGPathToLottie(customShape.path, drawCanvas.width, drawCanvas.height, originalPath);
            if (lottiePath && lottiePath.k) {
              // Ensure the path structure is correct
              if (lottiePath.k.v && Array.isArray(lottiePath.k.v) && lottiePath.k.v.length >= 3) {
                shape.ks = lottiePath;
                console.log("‚úì Applied custom path with", lottiePath.k.v.length, "vertices");
                console.log("  First vertex:", lottiePath.k.v[0]);
                console.log("  Last vertex:", lottiePath.k.v[lottiePath.k.v.length - 1]);
              } else {
                console.error("‚úó Invalid Lottie path structure:", lottiePath);
              }
            } else {
              console.error("‚úó Failed to convert path to Lottie format");
            }
          } else if (isFill1) {
            fillFound = true;
            console.log("Found fill element (fl) -", itemName || "unnamed");
            const rgba = hexToRgba(customShape.fill);
            const rgb = [rgba[0], rgba[1], rgba[2]]; // RGB only
            
            if (shape.c) {
              // Handle both static and animated colors
              if (shape.c.k !== undefined && shape.c.k !== null) {
                if (Array.isArray(shape.c.k) && (shape.c.k.length === 3 || shape.c.k.length === 4) && typeof shape.c.k[0] === 'number') {
                  // Static RGB/RGBA array
                  shape.c.k = rgb;
                  console.log("‚úì Applied fill color (static):", customShape.fill, "-> RGB:", rgb);
                } else if (Array.isArray(shape.c.k) && shape.c.k.length > 0) {
                  // Check if animated (keyframes)
                  const firstItem = shape.c.k[0];
                  if (typeof firstItem === 'object' && firstItem.s !== undefined) {
                    // Animated with keyframes
                    shape.c.k = shape.c.k.map(kf => {
                      if (typeof kf === 'object' && kf.s !== undefined) {
                        return { ...kf, s: rgb, e: rgb };
                      } else if (Array.isArray(kf) && (kf.length === 3 || kf.length === 4)) {
                        return rgb;
                      }
                      return kf;
                    });
                    console.log("‚úì Applied fill color (animated):", customShape.fill, "-> RGB:", rgb);
                  } else {
                    // Fallback: just set the array
                    shape.c.k = rgb;
                    console.log("‚úì Applied fill color (fallback):", customShape.fill, "-> RGB:", rgb);
                  }
                } else {
                  // Fallback: set directly
                  shape.c.k = rgb;
                  console.log("‚úì Applied fill color (direct):", customShape.fill, "-> RGB:", rgb);
                }
              } else {
                // Create color property if it doesn't exist
                shape.c.k = rgb;
                console.log("‚úì Created fill color:", customShape.fill, "-> RGB:", rgb);
              }
            } else {
              // Create color object if it doesn't exist
              shape.c = { a: 0, k: rgb };
              console.log("‚úì Created fill color object:", customShape.fill, "-> RGB:", rgb);
            }
          } else if (isStroke1) {
            strokeFound = true;
            console.log("Found stroke element (st) -", itemName || "unnamed");
            const rgba = hexToRgba(customShape.stroke);
            const rgb = [rgba[0], rgba[1], rgba[2]]; // RGB only
            
            if (shape.c) {
              // Handle both static and animated colors
              if (shape.c.k !== undefined && shape.c.k !== null) {
                if (Array.isArray(shape.c.k) && (shape.c.k.length === 3 || shape.c.k.length === 4) && typeof shape.c.k[0] === 'number') {
                  // Static RGB/RGBA array
                  shape.c.k = rgb;
                  console.log("‚úì Applied stroke color (static):", customShape.stroke, "-> RGB:", rgb);
                } else if (Array.isArray(shape.c.k) && shape.c.k.length > 0) {
                  // Check if animated (keyframes)
                  const firstItem = shape.c.k[0];
                  if (typeof firstItem === 'object' && firstItem.s !== undefined) {
                    // Animated with keyframes
                    shape.c.k = shape.c.k.map(kf => {
                      if (typeof kf === 'object' && kf.s !== undefined) {
                        return { ...kf, s: rgb, e: rgb };
                      } else if (Array.isArray(kf) && (kf.length === 3 || kf.length === 4)) {
                        return rgb;
                      }
                      return kf;
                    });
                    console.log("‚úì Applied stroke color (animated):", customShape.stroke, "-> RGB:", rgb);
                  } else {
                    // Fallback: just set the array
                    shape.c.k = rgb;
                    console.log("‚úì Applied stroke color (fallback):", customShape.stroke, "-> RGB:", rgb);
                  }
                } else {
                  // Fallback: set directly
                  shape.c.k = rgb;
                  console.log("‚úì Applied stroke color (direct):", customShape.stroke, "-> RGB:", rgb);
                }
              } else {
                // Create color property if it doesn't exist
                shape.c.k = rgb;
                console.log("‚úì Created stroke color:", customShape.stroke, "-> RGB:", rgb);
              }
            } else {
              // Create color object if it doesn't exist
              shape.c = { a: 0, k: rgb };
              console.log("‚úì Created stroke color object:", customShape.stroke, "-> RGB:", rgb);
            }
          }
        }
      } else {
        // Fallback: check if shapes are in groups
        for (const shape of layer.shapes) {
          if (shape.ty !== "gr") {
            console.log("Skipping non-group shape:", shape.ty);
            continue; // Not a group
          }
          
          // Look for path elements in the group
          if (!shape.it || !Array.isArray(shape.it)) {
            console.log("Shape group has no items array");
            continue;
          }
          
          console.log("Found shape group:", shape.nm || "unnamed", "items:", shape.it.length);
          
          for (const it of shape.it) {
            if (!it || !it.ty) continue;
            
            // Look for "Path 1", "Fill 1", "Stroke 1" by name or type
            const itemName = it.nm || "";
            const isPath1 = it.ty === "sh" && (itemName === "Path 1" || itemName.includes("Path") || !itemName);
            const isFill1 = it.ty === "fl" && (itemName === "Fill 1" || itemName.includes("Fill") || !itemName);
            const isStroke1 = it.ty === "st" && (itemName === "Stroke 1" || itemName.includes("Stroke") || !itemName);
          
          if (isPath1) { // Shape/path element (Path 1)
            pathFound = true;
            // Store original path for reference (to get position/scale)
            const originalPath = it.ks;
            console.log("Found path element (sh) -", itemName || "unnamed", "original path:", originalPath ? "exists" : "missing");
            if (originalPath && originalPath.k && originalPath.k.v) {
              console.log("Original path has", originalPath.k.v.length, "vertices");
              if (originalPath.k.v.length > 0) {
                console.log("Original first vertex:", originalPath.k.v[0]);
              }
            }
            
            // Convert SVG path to Lottie path format
            const lottiePath = convertSVGPathToLottie(customShape.path, drawCanvas.width, drawCanvas.height, originalPath);
            if (lottiePath && lottiePath.k) {
              // Ensure the path structure is correct
              if (lottiePath.k.v && Array.isArray(lottiePath.k.v) && lottiePath.k.v.length >= 3) {
                it.ks = lottiePath;
                console.log("‚úì Applied custom path with", lottiePath.k.v.length, "vertices");
                console.log("  First vertex:", lottiePath.k.v[0]);
                console.log("  Last vertex:", lottiePath.k.v[lottiePath.k.v.length - 1]);
              } else {
                console.error("‚úó Invalid Lottie path structure:", lottiePath);
              }
            } else {
              console.error("‚úó Failed to convert path to Lottie format");
            }
          } else if (isFill1) { // Fill element (Fill 1)
            fillFound = true;
            console.log("Found fill element (fl) -", itemName || "unnamed");
            const rgba = hexToRgba(customShape.fill);
            const rgb = [rgba[0], rgba[1], rgba[2]]; // RGB only
            
            if (it.c) {
              // Handle both static and animated colors
              if (it.c.k !== undefined && it.c.k !== null) {
                if (Array.isArray(it.c.k) && (it.c.k.length === 3 || it.c.k.length === 4) && typeof it.c.k[0] === 'number') {
                  // Static RGB/RGBA array
                  it.c.k = rgb;
                  console.log("‚úì Applied fill color (static):", customShape.fill, "-> RGB:", rgb);
                } else if (Array.isArray(it.c.k) && it.c.k.length > 0) {
                  // Check if animated (keyframes)
                  const firstItem = it.c.k[0];
                  if (typeof firstItem === 'object' && firstItem.s !== undefined) {
                    // Animated with keyframes
                    it.c.k = it.c.k.map(kf => {
                      if (typeof kf === 'object' && kf.s !== undefined) {
                        return { ...kf, s: rgb, e: rgb };
                      } else if (Array.isArray(kf) && (kf.length === 3 || kf.length === 4)) {
                        return rgb;
                      }
                      return kf;
                    });
                    console.log("‚úì Applied fill color (animated):", customShape.fill, "-> RGB:", rgb);
                  } else {
                    // Fallback: just set the array
                    it.c.k = rgb;
                    console.log("‚úì Applied fill color (fallback):", customShape.fill, "-> RGB:", rgb);
                  }
                } else {
                  // Fallback: set directly
                  it.c.k = rgb;
                  console.log("‚úì Applied fill color (direct):", customShape.fill, "-> RGB:", rgb);
                }
              } else {
                // Create color property if it doesn't exist
                it.c.k = rgb;
                console.log("‚úì Created fill color:", customShape.fill, "-> RGB:", rgb);
              }
            } else {
              // Create color object if it doesn't exist
              it.c = { a: 0, k: rgb };
              console.log("‚úì Created fill color object:", customShape.fill, "-> RGB:", rgb);
            }
          } else if (isStroke1) { // Stroke element (Stroke 1)
            strokeFound = true;
            console.log("Found stroke element (st) -", itemName || "unnamed");
            const rgba = hexToRgba(customShape.stroke);
            const rgb = [rgba[0], rgba[1], rgba[2]]; // RGB only
            
            if (it.c) {
              // Handle both static and animated colors
              if (it.c.k !== undefined && it.c.k !== null) {
                if (Array.isArray(it.c.k) && (it.c.k.length === 3 || it.c.k.length === 4) && typeof it.c.k[0] === 'number') {
                  // Static RGB/RGBA array
                  it.c.k = rgb;
                  console.log("‚úì Applied stroke color (static):", customShape.stroke, "-> RGB:", rgb);
                } else if (Array.isArray(it.c.k) && it.c.k.length > 0) {
                  // Check if animated (keyframes)
                  const firstItem = it.c.k[0];
                  if (typeof firstItem === 'object' && firstItem.s !== undefined) {
                    // Animated with keyframes
                    it.c.k = it.c.k.map(kf => {
                      if (typeof kf === 'object' && kf.s !== undefined) {
                        return { ...kf, s: rgb, e: rgb };
                      } else if (Array.isArray(kf) && (kf.length === 3 || kf.length === 4)) {
                        return rgb;
                      }
                      return kf;
                    });
                    console.log("‚úì Applied stroke color (animated):", customShape.stroke, "-> RGB:", rgb);
                  } else {
                    // Fallback: just set the array
                    it.c.k = rgb;
                    console.log("‚úì Applied stroke color (fallback):", customShape.stroke, "-> RGB:", rgb);
                  }
                } else {
                  // Fallback: set directly
                  it.c.k = rgb;
                  console.log("‚úì Applied stroke color (direct):", customShape.stroke, "-> RGB:", rgb);
                }
              } else {
                // Create color property if it doesn't exist
                it.c.k = rgb;
                console.log("‚úì Created stroke color:", customShape.stroke, "-> RGB:", rgb);
              }
            } else {
              // Create color object if it doesn't exist
              it.c = { a: 0, k: rgb };
              console.log("‚úì Created stroke color object:", customShape.stroke, "-> RGB:", rgb);
            }
          }
        }
      }
      }
      
      if (!pathFound) {
        console.error("‚úó No path element (sh) found in layer", layer.nm);
      }
      if (!fillFound) {
        console.warn("‚ö† No fill element (fl) found in layer", layer.nm);
      }
      if (!strokeFound) {
        console.warn("‚ö† No stroke element (st) found in layer", layer.nm);
      }
    }
    
    function convertSVGPathToLottie(svgPath, canvasWidth, canvasHeight, originalPath = null) {
      // Lottie path format requires vertices, inTangents, and outTangents
      // Format: { "a": 0, "k": { "v": [[x,y],...], "i": [[x,y],...], "o": [[x,y],...], "c": true } }
      
      // Parse SVG path commands (simplified - handles M, L, Z)
      const commands = svgPath.match(/[MLZ][^MLZ]*/g) || [];
      const points = [];
      
      let currentX = 0;
      let currentY = 0;
      
      for (const cmd of commands) {
        const type = cmd[0];
        const coords = cmd.slice(1).trim().split(/[\s,]+/).map(parseFloat).filter(n => !isNaN(n));
        
        if (type === "M" && coords.length >= 2) {
          // Move to
          currentX = coords[0];
          currentY = coords[1];
          points.push([currentX, currentY]);
        } else if (type === "L" && coords.length >= 2) {
          // Line to
          currentX = coords[0];
          currentY = coords[1];
          points.push([currentX, currentY]);
        } else if (type === "Z") {
          // Close path - ensure first and last points match
          if (points.length > 0) {
            const first = points[0];
            const last = points[points.length - 1];
            if (first[0] !== last[0] || first[1] !== last[1]) {
              points.push([first[0], first[1]]);
            }
          }
        }
      }
      
      if (points.length < 3) return null; // Need at least 3 points for a valid shape
      
      // Find bounding box of drawn path
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [x, y] of points) {
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
      
      const width = maxX - minX;
      const height = maxY - minY;
      
      if (width === 0 || height === 0) return null;
      
      const centerPathX = (minX + maxX) / 2;
      const centerPathY = (minY + maxY) / 2;
      
      // Try to match the original Heart's scale and position if available
      let targetSize = 60; // Default Heart size
      let offsetX = 0;
      let offsetY = 0;
      
      if (originalPath && originalPath.k && originalPath.k.v && originalPath.k.v.length > 0) {
        // Get original path bounds to match scale
        const origVertices = originalPath.k.v;
        let origMinX = Infinity, origMinY = Infinity, origMaxX = -Infinity, origMaxY = -Infinity;
        for (const [x, y] of origVertices) {
          origMinX = Math.min(origMinX, x);
          origMinY = Math.min(origMinY, y);
          origMaxX = Math.max(origMaxX, x);
          origMaxY = Math.max(origMaxY, y);
        }
        const origWidth = origMaxX - origMinX;
        const origHeight = origMaxY - origMinY;
        const origCenterX = (origMinX + origMaxX) / 2;
        const origCenterY = (origMinY + origMaxY) / 2;
        
        // Match the original size
        if (origWidth > 0 && origHeight > 0) {
          const scaleX = origWidth / width;
          const scaleY = origHeight / height;
          const scale = Math.min(scaleX, scaleY) * 0.8; // Slightly smaller to fit
          
          // Convert points to match original position and scale
          const vertices = points.map(([x, y]) => {
            const centeredX = (x - centerPathX) * scale;
            const centeredY = (y - centerPathY) * scale;
            return [centeredX + origCenterX, centeredY + origCenterY];
          });
          
          const inTangents = vertices.map(() => [0, 0]);
          const outTangents = vertices.map(() => [0, 0]);
          
          console.log("Converted path using original bounds:", {
            originalBounds: { width: origWidth, height: origHeight, center: [origCenterX, origCenterY] },
            newBounds: { width, height, center: [centerPathX, centerPathY] },
            scale: scale,
            firstVertex: vertices[0]
          });
          
          return {
            a: 0,
            k: {
              v: vertices,
              i: inTangents,
              o: outTangents,
              c: true
            }
          };
        }
      }
      
      // Fallback: scale to fit typical Heart size
      const scale = Math.min(targetSize / width, targetSize / height);
      
      // Convert points to Lottie coordinates (center at origin and scale)
      const vertices = points.map(([x, y]) => {
        const centeredX = (x - centerPathX) * scale;
        const centeredY = (y - centerPathY) * scale;
        return [centeredX, centeredY];
      });
      
      console.log("Converted path (fallback):", {
        canvasBounds: { width, height, center: [centerPathX, centerPathY] },
        scale: scale,
        firstVertex: vertices[0],
        vertexCount: vertices.length
      });
      
      // For simple polygons without curves, tangents are [0, 0]
      // Lottie requires inTangents and outTangents for each vertex
      const inTangents = vertices.map(() => [0, 0]);
      const outTangents = vertices.map(() => [0, 0]);
      
      // Lottie path format with proper structure
      return {
        a: 0, // Not animated
        k: {
          v: vertices,      // Vertices (actual points)
          i: inTangents,    // In tangents (bezier control points - [0,0] for straight lines)
          o: outTangents,   // Out tangents (bezier control points - [0,0] for straight lines)
          c: true           // Closed path
        }
      };
    }
    
    function saveDrawnShape() {
      if (!currentShapeName || vectorPoints.length < 3) {
        alert("Please add at least 3 points and close the path!");
        return;
      }
      
      if (!isPathClosed) {
        alert("Please close the path before saving!");
        return;
      }
      
      const fillColor = document.getElementById("drawFillColor").value.toUpperCase();
      const strokeColor = document.getElementById("drawStrokeColor").value.toUpperCase();
      const svgPath = convertPathToSVG();
      
      if (!svgPath) {
        alert("Could not create path. Please try again.");
        return;
      }
      
      // Test the Lottie conversion
      const testLottiePath = convertSVGPathToLottie(svgPath, drawCanvas.width, drawCanvas.height);
      if (!testLottiePath || !testLottiePath.k || !testLottiePath.k.v) {
        alert("Error creating Lottie path. Please try again.");
        console.error("Lottie path conversion failed:", testLottiePath);
        return;
      }
      
      // Save to state
      if (!state.customShapes) {
        state.customShapes = {};
      }
      
      state.customShapes[currentShapeName] = {
        path: svgPath,
        fill: fillColor,
        stroke: strokeColor,
        pathData: vectorPoints // Store vector points for editing
      };
      
      // Enable the accessory if it's not already enabled
      if (!state.accessories[currentShapeName]) {
        state.accessories[currentShapeName] = true;
        console.log("Enabled", currentShapeName, "accessory");
        // Update the toggle visually
        const heartRow = document.querySelector("#accessoriesGroup .toggle-row");
        if (heartRow) {
          const toggle = heartRow.querySelector(".toggle-switch");
          if (toggle) {
            toggle.classList.add("active");
          }
        }
      } else {
        console.log(currentShapeName, "accessory already enabled");
      }
      
      // Refresh accessories UI to show Edit button
      const container = document.getElementById("accessoriesGroup");
      container.innerHTML = "";
      setupAccessories();
      
      closeDrawModal();
      updatePreview();
    }
    
    function convertPathToSVG() {
      if (vectorPoints.length < 2) return null;
      
      // Convert vector points to SVG path string
      let pathString = `M ${vectorPoints[0].x} ${vectorPoints[0].y} `;
      
      for (let i = 1; i < vectorPoints.length; i++) {
        pathString += `L ${vectorPoints[i].x} ${vectorPoints[i].y} `;
      }
      
      // Close the path if it was closed
      if (isPathClosed && vectorPoints.length >= 3) {
        pathString += "Z";
      }
      
      return pathString;
    }

    function hexToRgba(hex) {
      hex = hex.replace("#", "");
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      return [r, g, b, 1];
    }

    function applyGlobalColor(kind, hex) {
      limbs.forEach(limb => {
        if (state.colors[limb][kind] !== undefined) {
          state.colors[limb][kind] = hex;
        }
      });
      updateGlobalColors();
      updatePreview();
    }

    function applyColorToLimb(limb, kind, hex) {
      if (state.colors[limb] && state.colors[limb][kind] !== undefined) {
        state.colors[limb][kind] = hex;
        updateAdvancedColors();
        updatePreview();
      }
    }

    function updateGlobalColors() {
      // Use first limb's colors as reference for global display
      const ref = state.colors.Head;
      document.getElementById("globalFill").value = ref.fill;
      document.getElementById("globalFillHex").value = ref.fill;
      document.getElementById("globalStroke").value = ref.stroke;
      document.getElementById("globalStrokeHex").value = ref.stroke;
      document.getElementById("globalStitch").value = ref.stitch;
      document.getElementById("globalStitchHex").value = ref.stitch;
    }

    function updateAdvancedColors() {
      if (!currentLimb) return;
      const colors = state.colors[currentLimb];
      document.getElementById("advancedFill").value = colors.fill || "#F1C799";
      document.getElementById("advancedFillHex").value = colors.fill || "#F1C799";
      document.getElementById("advancedStroke").value = colors.stroke || "#000000";
      document.getElementById("advancedStrokeHex").value = colors.stroke || "#000000";
      document.getElementById("advancedStitch").value = colors.stitch || "#000000";
      document.getElementById("advancedStitchHex").value = colors.stitch || "#000000";
    }

    function loadState(savedState) {
      if (savedState.colors) state.colors = savedState.colors;
      if (savedState.stitch_hashed !== undefined) state.stitch_hashed = savedState.stitch_hashed;
      // Handle legacy use_patch - migrate to TGpatch accessory
      if (savedState.use_patch !== undefined) {
        state.accessories.TGpatch = savedState.use_patch;
      }
      if (savedState.accessories) state.accessories = savedState.accessories;
      if (savedState.animation) {
        state.animation = savedState.animation;
        // Reload animation if it changed
        if (baseAnimationData) {
          loadAndRenderAnimation();
        }
      }
      if (savedState.customShapes) state.customShapes = savedState.customShapes;
      
      // Update animation buttons if they exist
      if (document.getElementById("animDefault")) {
        const animDefault = document.getElementById("animDefault");
        const animWave = document.getElementById("animWave");
        animDefault.classList.toggle("active", state.animation === "Default");
        animWave.classList.toggle("active", state.animation === "Wave");
      }
      
      updateGlobalColors();
      document.getElementById("stitchStyleToggle").classList.toggle("active", state.stitch_hashed);
      
      accessories.forEach((acc, idx) => {
        const toggle = document.querySelectorAll("#accessoriesGroup .toggle-switch")[idx];
        if (toggle) {
        toggle.classList.toggle("active", state.accessories[acc]);
        }
      });
      
      // Update preview if animation is already loaded
      if (baseAnimationData) {
        updatePreview();
      }
    }

    async function loadAndRenderAnimation() {
      try {
        // Check if lottie is loaded
        if (typeof lottie === 'undefined') {
          throw new Error("Lottie library not loaded");
        }
        
        const animationFile = state.animation === "Wave" ? "RigletBase.json" : "RigletTurn.json";
        const url = `https://riglets.github.io/RigletsFrontEnd/${animationFile}`;
        
        console.log("Loading animation from:", url);
        document.getElementById("previewPlaceholder").textContent = "Loading animation...";
        
        const response = await fetch(url);
        console.log("Response status:", response.status, response.statusText);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const contentType = response.headers.get("content-type");
        console.log("Content-Type:", contentType);
        
        if (!contentType || !contentType.includes("application/json")) {
          console.warn("Warning: Content-Type is not JSON:", contentType);
        }
        
        const jsonData = await response.json();
        console.log("Animation loaded successfully, layers:", jsonData.layers?.length || 0);
        
        baseAnimationData = jsonData;
        updatePreview();
      } catch (error) {
        console.error("Error loading animation:", error);
        const errorMsg = error.message || "Unknown error";
        document.getElementById("previewPlaceholder").textContent = 
          `Failed to load preview: ${errorMsg}. Check console for details.`;
        
        // Show more helpful error message
        if (errorMsg.includes("404") || errorMsg.includes("Not Found")) {
          document.getElementById("previewPlaceholder").textContent = 
            "File not found. Make sure RigletTurn.json and RigletBase.json are in your GitHub Pages repo and accessible at: https://riglets.github.io/RigletsFrontEnd/";
        } else if (errorMsg.includes("CORS") || errorMsg.includes("Failed to fetch")) {
          document.getElementById("previewPlaceholder").textContent = 
            "Network error. Check if GitHub Pages is enabled and files are accessible.";
        } else if (errorMsg.includes("JSON")) {
          document.getElementById("previewPlaceholder").textContent = 
            "Invalid JSON file. Make sure the JSON files are valid.";
        }
      }
    }

    function applyColorsToAnimation(data, colors, stitchHashed) {
      // Deep clone the data to avoid modifying the original
      // Use the same approach as bot.py - load fresh JSON structure
      const animData = JSON.parse(JSON.stringify(data));
      
      console.log("Applying stitch_hashed:", stitchHashed);
      
      // Apply colors
      for (const layer of animData.layers || []) {
        const layerName = layer.nm;
        
        // Skip layers that have custom shapes (they'll be handled separately with custom colors)
        // Only skip the original Heart layer, not CustomHeart (CustomHeart needs its colors applied)
        const hasCustomShape = state.customShapes && Object.keys(state.customShapes).some(accName => {
          const layerNames = ACCESSORY_LAYERS[accName] || [];
          // Only skip if this is the original layer (not CustomHeart) and has a custom shape
          return layerNames.includes(layerName) && layerName !== "CustomHeart" && state.customShapes[accName];
        });
        
        if (hasCustomShape) {
          console.log(`Skipping default color application for ${layerName} (has custom shape with custom colors)`);
          continue;
        }
        
        if (!RIGLET_GROUPS[layerName]) continue;
        
        const limbDef = RIGLET_GROUPS[layerName];
        const colorDef = colors[layerName] || {};
        
        for (const shape of layer.shapes || []) {
          if (!shape || shape.ty !== "gr") continue;
          
          const groupName = shape.nm;
          const targets = [];
          
          if (limbDef.fill && limbDef.fill.includes(groupName)) {
            const fillColor = colorDef.fill;
            if (fillColor) {
              targets.push({ kind: "fill", color: fillColor });
              console.log(`Found fill target: ${layerName}/${groupName} -> ${fillColor}`);
            }
          }
          
          if (limbDef.stroke && limbDef.stroke.includes(groupName)) {
            const strokeColor = colorDef.stroke;
            if (strokeColor) {
              targets.push({ kind: "stroke", color: strokeColor });
              console.log(`Found stroke target: ${layerName}/${groupName} -> ${strokeColor}`);
            }
          }
          
          if (limbDef.stitch && limbDef.stitch.includes(groupName)) {
            const stitchColor = colorDef.stitch;
            if (stitchColor) {
              targets.push({ kind: "stitch", color: stitchColor });
              console.log(`Found stitch target: ${layerName}/${groupName} -> ${stitchColor}`);
            }
          }
          
          if (targets.length === 0) continue; // Skip if no targets found
          
          console.log(`Processing ${targets.length} targets for ${layerName}/${groupName}`);
          
          for (const target of targets) {
            const rgba = hexToRgba(target.color);
            console.log(`  Target: ${target.kind}, color: ${target.color}, rgba:`, rgba);
            
            if (!shape.it || !Array.isArray(shape.it)) {
              console.log(`  No shape.it array found for ${layerName}/${groupName}`);
              continue;
            }
            
            console.log(`  Shape has ${shape.it.length} items`);
            
            for (const it of shape.it) {
              if (!it || !it.ty) continue;
              const ty = it.ty;
              
              if (ty === "fl" && target.kind === "fill") {
                console.log(`  Found fill element (fl) in ${layerName}/${groupName}`);
                if (it.c && it.c.k !== undefined && it.c.k !== null) {
                  console.log(`  Fill color structure:`, Array.isArray(it.c.k) ? `array[${it.c.k.length}]` : typeof it.c.k, it.c.k);
                  
                  // Extract RGB (first 3 values) from RGBA
                  const rgb = [rgba[0], rgba[1], rgba[2]];
                  
                  // Check if it's a static color array (RGB or RGBA)
                  if (Array.isArray(it.c.k) && (it.c.k.length === 3 || it.c.k.length === 4) && typeof it.c.k[0] === 'number') {
                    // Static RGB/RGBA array - replace with RGB (Lottie uses RGB for fills)
                    console.log(`  ‚úì Applying fill color (RGB) to ${layerName}/${groupName}:`, rgb);
                    it.c.k = rgb;
                  } else if (Array.isArray(it.c.k) && it.c.k.length > 0) {
                    // Check if it's animated (keyframes)
                    const firstItem = it.c.k[0];
                    console.log(`  Fill is animated, first item:`, typeof firstItem, firstItem);
                    if (typeof firstItem === 'object' && firstItem.s !== undefined) {
                      // Animated with keyframes - modify the start/end values
                      console.log(`  ‚úì Applying animated fill color (keyframes) to ${layerName}/${groupName}`);
                      it.c.k = it.c.k.map(kf => {
                        if (typeof kf === 'object' && kf.s !== undefined) {
                          // Keyframe with start/end values
                          const startRGB = Array.isArray(kf.s) && kf.s.length >= 3 ? kf.s.slice(0, 3) : rgb;
                          const endRGB = Array.isArray(kf.e) && kf.e.length >= 3 ? kf.e.slice(0, 3) : rgb;
                          return { ...kf, s: [rgb], e: [rgb] };
                        } else if (Array.isArray(kf) && (kf.length === 3 || kf.length === 4)) {
                          return rgb;
                        }
                        return kf;
                      });
                    } else if (typeof firstItem === 'number') {
                      // Array of numbers (RGB values) - this is the animated RGB array
                      console.log(`  ‚úì Applying fill color (animated RGB array) to ${layerName}/${groupName}`);
                      it.c.k = rgb;
                    } else {
                      console.warn(`  ‚ö† Unknown fill color structure for ${layerName}/${groupName}`);
                    }
                  } else {
                    console.warn(`  ‚ö† Fill color structure not recognized:`, typeof it.c.k, it.c.k);
                  }
                } else {
                  console.warn(`  ‚ö† No fill color property (it.c) found for ${layerName}/${groupName}`);
                }
              }
              
              if (ty === "st" && (target.kind === "stroke" || target.kind === "stitch")) {
                console.log(`  Found stroke element (st) in ${layerName}/${groupName}, kind: ${target.kind}`);
                if (it.c && it.c.k !== undefined && it.c.k !== null) {
                  console.log(`  Stroke color structure:`, Array.isArray(it.c.k) ? `array[${it.c.k.length}]` : typeof it.c.k, it.c.k);
                  
                  // Extract RGB (first 3 values) from RGBA
                  const rgb = [rgba[0], rgba[1], rgba[2]];
                  
                  // Check if it's a static color array (RGB or RGBA)
                  if (Array.isArray(it.c.k) && (it.c.k.length === 3 || it.c.k.length === 4) && typeof it.c.k[0] === 'number') {
                    // Static RGB/RGBA array - replace with RGB (Lottie uses RGB for strokes)
                    console.log(`  ‚úì Applying ${target.kind} color (RGB) to ${layerName}/${groupName}:`, rgb);
                    it.c.k = rgb;
                  } else if (Array.isArray(it.c.k) && it.c.k.length > 0) {
                    // Check if it's animated (keyframes)
                    const firstItem = it.c.k[0];
                    console.log(`  Stroke is animated, first item:`, typeof firstItem, firstItem);
                    if (typeof firstItem === 'object' && firstItem.s !== undefined) {
                      // Animated with keyframes - modify the start/end values
                      console.log(`  ‚úì Applying animated ${target.kind} color (keyframes) to ${layerName}/${groupName}`);
                      it.c.k = it.c.k.map(kf => {
                        if (typeof kf === 'object' && kf.s !== undefined) {
                          // Keyframe with start/end values
                          const startRGB = Array.isArray(kf.s) && kf.s.length >= 3 ? kf.s.slice(0, 3) : rgb;
                          const endRGB = Array.isArray(kf.e) && kf.e.length >= 3 ? kf.e.slice(0, 3) : rgb;
                          return { ...kf, s: [rgb], e: [rgb] };
                        } else if (Array.isArray(kf) && (kf.length === 3 || kf.length === 4)) {
                          return rgb;
                        }
                        return kf;
                      });
                    } else if (typeof firstItem === 'number') {
                      // Array of numbers (RGB values) - this is the animated RGB array
                      console.log(`  ‚úì Applying ${target.kind} color (animated RGB array) to ${layerName}/${groupName}`);
                      it.c.k = rgb;
                    } else {
                      console.warn(`  ‚ö† Unknown stroke color structure for ${layerName}/${groupName}`);
                    }
                  } else {
                    console.warn(`  ‚ö† Stroke color structure not recognized:`, typeof it.c.k, it.c.k);
                  }
                } else {
                  console.warn(`  ‚ö† No stroke color property (it.c) found for ${layerName}/${groupName}`);
                }
              
                // Process stitch dash - only for stroke elements (ty === "st")
                // Match bot.py structure exactly: it["d"] = [{"n": "d", "v": {"a": 0, "k": STITCH_DASH_LENGTH}}, {"n": "o", "v": {"a": 0, "k": 0}}]
                // The bot does: it["d"] = [...] directly, and it.pop("d", None) to remove
                // NOTE: Temporarily disabled - Lottie-web has issues with programmatically added dash arrays
                // The structure is correct but causes "Cannot redefine property: undefined" errors
                // Dash arrays will still work when sent to bot (bot creates file, not browser Lottie)
                if (target.kind === "stitch" && ty === "st" && false) {
                  if (stitchHashed) {
                    // Apply dash array - match bot.py exactly
                    // Bot does: it["d"] = [{"n": "d", "v": {"a": 0, "k": STITCH_DASH_LENGTH}}, {"n": "o", "v": {"a": 0, "k": 0}}]
                    it.d = [
                      { n: "d", v: { a: 0, k: STITCH_DASH_LENGTH } },
                      { n: "o", v: { a: 0, k: 0 } }
                    ];
                    console.log(`  ‚úì Applied dash array to stitch ${layerName}/${groupName}`);
                  } else {
                    // Remove dash array - match bot.py: it.pop("d", None)
                    // In JavaScript, we use delete instead of pop
                    if (it.d !== undefined) {
                      delete it.d;
                      console.log(`  ‚úì Removed dash array from stitch ${layerName}/${groupName}`);
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      // Apply accessories visibility and custom shapes
      // IMPORTANT: This must run AFTER applyColorsToAnimation to ensure custom colors aren't overwritten
      console.log("Checking for custom shapes. state.customShapes:", state.customShapes);
      console.log("Available layers:", animData.layers?.map(l => l.nm) || []);
      for (const layer of animData.layers || []) {
        const layerName = layer.nm;
        for (const [accName, layerNames] of Object.entries(ACCESSORY_LAYERS)) {
          if (layerNames.includes(layerName)) {
            console.log(`Layer ${layerName} matches accessory ${accName} (layers: ${layerNames.join(", ")})`);
            const isEnabled = state.accessories[accName];
            
            // For Heart accessory: if custom shape exists, show CustomHeart and hide Heart
            // Otherwise, show Heart and hide CustomHeart
            if (accName === "Heart") {
              if (isEnabled && state.customShapes && state.customShapes[accName]) {
                // Custom shape exists - show CustomHeart, hide Heart
                if (layerName === "CustomHeart") {
                  layer.hd = false; // Show CustomHeart
                  console.log("‚úì Showing CustomHeart layer (custom shape exists)");
                } else if (layerName === "Heart") {
                  layer.hd = true; // Hide original Heart
                  console.log("‚úì Hiding Heart layer (custom shape exists)");
                }
              } else {
                // No custom shape - show Heart, hide CustomHeart
                if (layerName === "Heart") {
                  layer.hd = !isEnabled; // Show/hide based on toggle
                } else if (layerName === "CustomHeart") {
                  layer.hd = true; // Always hide CustomHeart when no custom shape
                }
              }
            } else {
              // For other accessories, just toggle visibility
              layer.hd = !isEnabled;
            }
            
            // If this is CustomHeart and has a custom drawn shape, apply it
            if (layerName === "CustomHeart") {
              console.log("Found CustomHeart layer. Checking conditions:", {
                isEnabled,
                hasCustomShapes: !!state.customShapes,
                hasHeartCustomShape: !!(state.customShapes && state.customShapes[accName]),
                accName: accName
              });
              if (isEnabled && state.customShapes && state.customShapes[accName]) {
                console.log("‚úì Applying custom shape to CustomHeart layer:", state.customShapes[accName]);
                applyCustomShapeToLayer(layer, state.customShapes[accName]);
              }
            }
          }
        }
      }
      
      // Apply patch visibility - remove TGpatch from Left_Leg if patch is off
      for (const layer of animData.layers || []) {
        if (layer.nm === "Left_Leg" && layer.shapes) {
          layer.shapes = layer.shapes.filter(shape => {
            if (shape.nm === "TGpatch" && !state.accessories.TGpatch) {
              return false; // Remove patch
            }
            return true; // Keep other shapes
          });
        }
      }
      
      // Re-serialize and parse to ensure clean structure (like bot.py writes to file then reads)
      // This ensures Lottie gets a completely fresh object without any internal references
      // The bot writes JSON to file then reads it, which gives a clean structure
      try {
        const serialized = JSON.stringify(animData);
        const cleaned = JSON.parse(serialized);
        console.log("Animation data cleaned and re-parsed (like bot.py file write/read)");
        return cleaned;
      } catch (e) {
        console.error("Error cleaning animation data:", e);
        return animData;
      }
    }

    function updatePreview() {
      if (!baseAnimationData) {
        console.log("No animation data available yet");
        return;
      }
      
      // Check if lottie is loaded
      if (typeof lottie === 'undefined') {
        console.error("Lottie library not available");
        document.getElementById("previewPlaceholder").textContent = "Lottie library not loaded";
        document.getElementById("previewPlaceholder").classList.remove("hidden");
        document.getElementById("lottieContainer").classList.add("hidden");
        return;
      }
      
      // Debounce updates for performance
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }
      
      updateTimeout = setTimeout(() => {
        try {
          console.log("Applying colors to animation...");
          const coloredData = applyColorsToAnimation(
            baseAnimationData,
            state.colors,
            state.stitch_hashed
          );
          
          console.log("Animation data processed, layers:", coloredData.layers?.length);
          
          // Clear the container first
          const container = document.getElementById("lottieContainer");
          container.innerHTML = '';
          
          // Destroy existing instance
          if (lottieInstance) {
            try {
              lottieInstance.destroy();
            } catch (e) {
              console.warn("Error destroying previous instance:", e);
            }
            lottieInstance = null;
          }
          
          // Destroy existing instance first
          if (lottieInstance) {
            try {
              lottieInstance.destroy();
            } catch (e) {
              console.warn("Error destroying previous instance:", e);
            }
            lottieInstance = null;
          }
          
          // Clear the container
          container.innerHTML = '';
          
          // Hide placeholder, show container
          const placeholder = document.getElementById("previewPlaceholder");
          placeholder.classList.add("hidden");
          container.classList.remove("hidden");
          
          // Ensure container is visible and has size
          console.log("Container dimensions:", container.offsetWidth, "x", container.offsetHeight);
          console.log("Container display:", window.getComputedStyle(container).display);
          console.log("Container visibility:", window.getComputedStyle(container).visibility);
          
          // Create new instance with updated data
          console.log("Rendering animation with Lottie...");
          console.log("Animation data keys:", Object.keys(coloredData));
          console.log("Animation width:", coloredData.w, "height:", coloredData.h);
          console.log("Animation frame rate:", coloredData.fr);
          console.log("Animation total frames:", coloredData.op);
          
          lottieInstance = lottie.loadAnimation({
            container: container,
            renderer: "svg",
            loop: true,
            autoplay: true,
            animationData: coloredData
          });
          
          // Set explicit size based on animation dimensions
          if (coloredData.w && coloredData.h) {
            const aspectRatio = coloredData.w / coloredData.h;
            const maxSize = 240; // Optimized for MiniApp display
            let width, height;
            if (aspectRatio > 1) {
              width = maxSize;
              height = maxSize / aspectRatio;
            } else {
              height = maxSize;
              width = maxSize * aspectRatio;
            }
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            console.log("Set container size to:", width, "x", height);
          }
          
          // Ensure animation plays
          if (lottieInstance) {
            lottieInstance.play();
            console.log("Forced animation to play");
          }
          
          // Add event listeners to check if animation loaded
          lottieInstance.addEventListener('data_ready', () => {
            console.log("Lottie animation data ready");
            console.log("Container after data ready:", container.innerHTML.length, "chars");
          });
          
          lottieInstance.addEventListener('DOMLoaded', () => {
            console.log("Lottie animation DOM loaded");
            console.log("Container has SVG:", container.querySelector('svg') !== null);
            const svg = container.querySelector('svg');
            if (svg) {
              console.log("SVG dimensions:", svg.offsetWidth, "x", svg.offsetHeight);
              console.log("SVG viewBox:", svg.getAttribute('viewBox'));
              console.log("SVG computed style:", window.getComputedStyle(svg).display);
              console.log("SVG computed visibility:", window.getComputedStyle(svg).visibility);
              
              // Force SVG to be visible
              svg.style.width = '100%';
              svg.style.height = '100%';
              svg.style.display = 'block';
              svg.style.visibility = 'visible';
            }
          });
          
          let errorLogged = false;
          lottieInstance.addEventListener('error', (error) => {
            if (!errorLogged) {
              errorLogged = true;
              console.error("Lottie animation error:", error);
              console.error("Error details:", error.nativeError);
              placeholder.classList.remove("hidden");
              container.classList.add("hidden");
              placeholder.textContent = 
                `Animation render error. Check console for details.`;
            }
          });
          
          console.log("Animation instance created");
          
          // Check after a short delay if SVG was created and get its properties
          setTimeout(() => {
            const svg = container.querySelector('svg');
            if (svg) {
              console.log("‚úì SVG successfully rendered in container");
              console.log("SVG actual size:", svg.offsetWidth, "x", svg.offsetHeight);
              console.log("SVG client size:", svg.clientWidth, "x", svg.clientHeight);
              console.log("SVG bounding rect:", svg.getBoundingClientRect());
              console.log("SVG viewBox:", svg.getAttribute('viewBox'));
              console.log("SVG style:", svg.style.cssText);
              console.log("SVG computed width:", window.getComputedStyle(svg).width);
              console.log("SVG computed height:", window.getComputedStyle(svg).height);
              
              // Check if animation is playing
              if (lottieInstance) {
                console.log("Animation total frames:", lottieInstance.totalFrames);
                console.log("Animation current frame:", lottieInstance.currentFrame);
                console.log("Animation is playing:", !lottieInstance.isPaused);
                
                // Force play if paused
                if (lottieInstance.isPaused) {
                  console.log("Animation was paused, forcing play...");
                  lottieInstance.play();
                }
              }
              
              // Try to force visibility
              svg.style.width = '240px';
              svg.style.height = '240px';
              svg.style.display = 'block';
              svg.style.visibility = 'visible';
              svg.style.opacity = '1';
              
              // Check if SVG has any visible elements
              const paths = svg.querySelectorAll('path, circle, rect, ellipse, polygon');
              console.log("SVG has", paths.length, "drawable elements");
              if (paths.length > 0) {
                const firstPath = paths[0];
                console.log("First element fill:", window.getComputedStyle(firstPath).fill);
                console.log("First element stroke:", window.getComputedStyle(firstPath).stroke);
                console.log("First element opacity:", window.getComputedStyle(firstPath).opacity);
              }
            } else {
              console.warn("‚ö† No SVG found in container after 500ms");
              console.log("Container HTML:", container.innerHTML.substring(0, 200));
            }
          }, 500);
        } catch (error) {
          console.error("Error updating preview:", error);
          document.getElementById("previewPlaceholder").classList.remove("hidden");
          document.getElementById("lottieContainer").classList.add("hidden");
          document.getElementById("previewPlaceholder").textContent = 
            `Error rendering preview: ${error.message}`;
        }
      }, 100); // 100ms debounce for smooth updates
    }

    function sendState(action) {
      const data = {
        action: action,
        colors: state.colors,
        stitch_hashed: state.stitch_hashed,
        use_patch: state.accessories.TGpatch, // Map TGpatch to use_patch for bot compatibility
        accessories: state.accessories,
        animation: state.animation,
        customShapes: state.customShapes || {}
      };
      
      if (tg) {
      tg.sendData(JSON.stringify(data));
      
      if (action === "done") {
        tg.close();
        }
      } else {
        console.error("Telegram WebApp not available, cannot send data");
      }
    }

    // Wait for DOM and scripts to load
    function startApp() {
      console.log("Starting app initialization...");
      console.log("Lottie available:", typeof lottie !== 'undefined');
      console.log("Telegram WebApp available:", tg !== null && tg !== undefined, tg);
      
      if (typeof lottie === 'undefined') {
        console.warn("Lottie not loaded yet, waiting...");
        document.getElementById("previewPlaceholder").textContent = "Loading Lottie library...";
        
        // Check every 100ms for lottie
        const checkLottie = setInterval(() => {
          if (typeof lottie !== 'undefined') {
            clearInterval(checkLottie);
            console.log("Lottie loaded, initializing app...");
    init();
          }
        }, 100);
        
        // Give up after 5 seconds
        setTimeout(() => {
          if (typeof lottie === 'undefined') {
            clearInterval(checkLottie);
            console.error("Lottie library failed to load after 5 seconds");
            document.getElementById("previewPlaceholder").textContent = 
              "Failed to load Lottie library. Please check your internet connection.";
          }
        }, 5000);
      } else {
        console.log("Lottie already loaded, initializing immediately...");
        init();
      }
    }
    
    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', startApp);
    } else {
      // DOM already loaded
      startApp();
    }
    
    // Also try on window load as backup (but only if not already initialized)
    window.addEventListener('load', () => {
      if (!isInitialized && typeof lottie !== 'undefined') {
        console.log("Window loaded, checking if we need to initialize...");
        if (!baseAnimationData) {
          console.log("Initializing from window load event...");
          init();
        }
      }
    });
  </script>
</body>
</html>



