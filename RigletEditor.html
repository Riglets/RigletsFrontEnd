<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Riglet Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js" 
          onload="console.log('Lottie script loaded successfully');" 
          onerror="console.error('Failed to load Lottie script');"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--tg-theme-bg-color, #111);
      color: var(--tg-theme-text-color, #fff);
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    
    .header {
      padding: 12px 16px;
      text-align: center;
      border-bottom: 1px solid var(--tg-theme-hint-color, #333);
      background: var(--tg-theme-secondary-bg-color, #1a1a1a);
    }
    
    .header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    
    .preview-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: var(--tg-theme-bg-color, #111);
      min-height: 180px;
      position: relative;
      overflow: hidden;
    }
    
    .preview-placeholder {
      text-align: center;
      color: var(--tg-theme-hint-color, #888);
      font-size: 14px;
    }
    
    .preview-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    #lottieContainer {
      width: 100%;
      height: 100%;
      max-width: 240px;
      max-height: 240px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    #lottieContainer svg {
      width: 100% !important;
      height: 100% !important;
      max-width: 240px !important;
      max-height: 240px !important;
      display: block !important;
      visibility: visible !important;
    }
    
    .tools-container {
      background: var(--tg-theme-secondary-bg-color, #1a1a1a);
      border-top: 1px solid var(--tg-theme-hint-color, #333);
      padding: 16px;
      overflow-y: auto;
      max-height: 50vh;
    }
    
    .tool-section {
      margin-bottom: 20px;
    }
    
    .tool-section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--tg-theme-hint-color, #aaa);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .color-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .color-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .color-label {
      min-width: 80px;
      font-size: 14px;
    }
    
    .color-input-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    input[type="color"] {
      width: 50px;
      height: 50px;
      border: 2px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      padding: 0;
      background: none;
      cursor: pointer;
    }
    
    .color-hex {
      font-family: monospace;
      font-size: 14px;
      padding: 8px 12px;
      background: var(--tg-theme-bg-color, #222);
      border: 1px solid var(--tg-theme-hint-color, #444);
      border-radius: 6px;
      color: var(--tg-theme-text-color, #fff);
      min-width: 80px;
      text-align: center;
    }
    
    .preset-colors {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    
    .preset-btn {
      aspect-ratio: 1;
      border: 2px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.1s;
    }
    
    .preset-btn:active {
      transform: scale(0.95);
    }
    
    .toggle-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--tg-theme-bg-color, #222);
      border-radius: 8px;
    }
    
    .toggle-label {
      font-size: 14px;
    }
    
    .toggle-switch {
      position: relative;
      width: 50px;
      height: 28px;
      background: var(--tg-theme-hint-color, #444);
      border-radius: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .toggle-switch.active {
      background: var(--tg-theme-button-color, #3390ec);
    }
    
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 24px;
      background: #fff;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
    }
    
    .toggle-switch.active::after {
      transform: translateX(22px);
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    button {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    button:active {
      opacity: 0.8;
    }
    
    .btn-preview {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
    }
    
    .btn-done {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
    }
    
    .btn-secondary {
      background: var(--tg-theme-secondary-bg-color, #2a2a2a);
      color: var(--tg-theme-text-color, #fff);
    }
    
    .btn-preset {
      background: var(--tg-theme-secondary-bg-color, #2a2a2a);
      color: var(--tg-theme-text-color, #fff);
      border: 2px solid transparent;
    }
    
    .btn-preset.active {
      background: var(--tg-theme-button-color, #3390ec);
      color: var(--tg-theme-button-text-color, #fff);
      border-color: var(--tg-theme-button-color, #3390ec);
    }
    
    .limb-selector {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    
    .limb-btn {
      padding: 10px;
      background: var(--tg-theme-bg-color, #222);
      border: 1px solid var(--tg-theme-hint-color, #444);
      border-radius: 8px;
      color: var(--tg-theme-text-color, #fff);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .limb-btn.active {
      background: var(--tg-theme-button-color, #3390ec);
      border-color: var(--tg-theme-button-color, #3390ec);
    }
    
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="header">
    <h2>Riglet Editor</h2>
  </div>
  
  <div class="preview-container">
    <div class="preview-placeholder" id="previewPlaceholder">
      Loading Riglet preview...
    </div>
    <div id="lottieContainer" class="hidden"></div>
  </div>
  
  <div class="tools-container">
    <!-- Global Colors -->
    <div class="tool-section">
      <div class="tool-section-title">Global Colors</div>
      <div class="color-group">
        <div class="color-row">
          <span class="color-label">Fill:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalFill" value="#F1C799" />
            <input type="text" class="color-hex" id="globalFillHex" value="#F1C799" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stroke:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalStroke" value="#000000" />
            <input type="text" class="color-hex" id="globalStrokeHex" value="#000000" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stitch:</span>
          <div class="color-input-wrapper">
            <input type="color" id="globalStitch" value="#000000" />
            <input type="text" class="color-hex" id="globalStitchHex" value="#000000" maxlength="7" />
          </div>
        </div>
        <div class="preset-colors" id="presetColors"></div>
      </div>
    </div>
    
    <!-- Advanced Mode -->
    <div class="tool-section">
      <div class="tool-section-title">Advanced Coloring</div>
      <div class="limb-selector" id="limbSelector"></div>
      <div class="color-group hidden" id="advancedColors">
        <div class="color-row">
          <span class="color-label">Fill:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedFill" value="#F1C799" />
            <input type="text" class="color-hex" id="advancedFillHex" value="#F1C799" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stroke:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedStroke" value="#000000" />
            <input type="text" class="color-hex" id="advancedStrokeHex" value="#000000" maxlength="7" />
          </div>
        </div>
        <div class="color-row">
          <span class="color-label">Stitch:</span>
          <div class="color-input-wrapper">
            <input type="color" id="advancedStitch" value="#000000" />
            <input type="text" class="color-hex" id="advancedStitchHex" value="#000000" maxlength="7" />
          </div>
        </div>
      </div>
    </div>
    
    <!-- Accessories -->
    <div class="tool-section">
      <div class="tool-section-title">Accessories</div>
      <div class="toggle-group" id="accessoriesGroup"></div>
    </div>
    
    <!-- Options -->
    <div class="tool-section">
      <div class="tool-section-title">Options</div>
      <div class="toggle-group">
        <div class="toggle-row">
          <span class="toggle-label">Stitch Style (Hashed)</span>
          <div class="toggle-switch active" id="stitchStyleToggle"></div>
        </div>
      </div>
      <div class="tool-section-title" style="margin-top: 16px;">Animation</div>
      <div class="button-group" style="flex-direction: column; gap: 8px;">
        <button class="btn-preset" id="animDefault">Default</button>
        <button class="btn-preset" id="animWave">Wave</button>
      </div>
    </div>
    
    <!-- Actions -->
    <div class="button-group">
      <button class="btn-preview" id="previewBtn">Preview</button>
      <button class="btn-done" id="doneBtn">Done</button>
    </div>
  </div>

  <script>
    // Define tg in global scope so all functions can access it
    let tg = null;
    
    // Initialize Telegram WebApp immediately
    try {
      console.log("=== RIGLET EDITOR SCRIPT STARTING ===");
      console.log("Window loaded:", typeof window !== 'undefined');
      console.log("Document ready state:", document.readyState);
      
      if (typeof window !== 'undefined' && window.Telegram && window.Telegram.WebApp) {
        tg = window.Telegram.WebApp;
        console.log("Telegram WebApp object: available");
        
        if (tg) {
    tg.ready();
    tg.expand();
          console.log("Telegram WebApp initialized");
        }
      } else {
        console.log("Telegram WebApp not available (running outside Telegram)");
      }
    } catch (e) {
      console.error("Error in initial script:", e);
      const placeholder = document.getElementById("previewPlaceholder");
      if (placeholder) {
        placeholder.textContent = "Script error: " + e.message;
      }
    }

    // Default state
    const state = {
      colors: {
        Head: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Left_Arm: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Right_Arm: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Left_Leg: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Right_Leg: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" },
        Body: { fill: "#F1C799", stroke: "#000000", stitch: "#000000" }
      },
      stitch_hashed: true,
      accessories: {
        Halo: false,
        Heart: false,
        Wings: false,
        CherryStem: false,
        Bow: false,
        Seeds: false,
        TGpatch: false
      },
      animation: "Default"
    };

    // Preset colors
    const presets = [
      { name: "Peach", hex: "#F1C799" },
      { name: "Tan", hex: "#C88C55" },
      { name: "Pink", hex: "#F49BC1" },
      { name: "Blue", hex: "#8FC7FF" },
      { name: "Mint", hex: "#A0FFD1" },
      { name: "White", hex: "#FFFFFF" },
      { name: "Black", hex: "#000000" }
    ];

    const limbs = ["Head", "Body", "Left_Arm", "Right_Arm", "Left_Leg", "Right_Leg"];
    const accessories = ["Halo", "Heart", "Wings", "CherryStem", "Bow", "Seeds", "TGpatch"];

    // Riglet groups mapping (matches bot.py)
    const RIGLET_GROUPS = {
      "Head": {
        "fill": ["StrokeFill"],
        "stroke": ["Stroke", "StrokeFill"],
        "stitch": ["Stitch"],
      },
      "Left_Arm": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch"],
      },
      "Right_Arm": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch"],
      },
      "Left_Leg": {
        "fill": ["Fill", "StrokeFill"],
        "stroke": ["Stroke", "StrokeFill"],
        "stitch": ["Stitch"],
      },
      "Right_Leg": {
        "fill": ["Fill"],
        "stroke": ["Stroke"],
        "stitch": ["Stitch1", "Stitch2"],
      },
      "Body": {
        "fill": ["StrokeFill"],
        "stroke": ["StrokeFill"],
      },
    };

    const ACCESSORY_LAYERS = {
      "Halo": ["halofront", "haloback"],
      "Heart": ["Heart"],
      "Wings": ["Wings", "Wings 2"],
      "CherryStem": ["CherryStem"],
      "Bow": ["Bow"],
      "Seeds": ["Seeds"],
    };

    const STITCH_DASH_LENGTH = 10.0;

    let currentLimb = null;
    let isAdvancedMode = false;
    let baseAnimationData = null;
    let lottieInstance = null;
    let updateTimeout = null;
    let isInitialized = false; // Prevent duplicate initialization

    // Initialize UI
    async function init() {
      // Prevent duplicate initialization
      if (isInitialized) {
        console.log("Already initialized, skipping...");
        return;
      }
      isInitialized = true;
      
      console.log("=== INIT STARTING ===");
      console.log("Setting up UI components...");
      
      setupPresets();
      setupLimbSelector();
      setupAccessories();
      setupColorInputs();
      setupToggles();
      setupButtons();
      
      console.log("UI components set up");
      
      // Try to load initial state from initData if available
      if (tg && tg.initDataUnsafe && tg.initDataUnsafe.start_param) {
        try {
          console.log("Loading saved state from initData...");
          const savedState = JSON.parse(decodeURIComponent(tg.initDataUnsafe.start_param));
          loadState(savedState);
        } catch (e) {
          console.log("No saved state found or error parsing:", e);
        }
      } else {
        console.log("No initData.start_param available");
      }
      
      // Load and render the animation
      console.log("Starting animation load...");
      await loadAndRenderAnimation();
      console.log("=== INIT COMPLETE ===");
    }

    function setupPresets() {
      const container = document.getElementById("presetColors");
      presets.forEach(preset => {
        const btn = document.createElement("button");
        btn.className = "preset-btn";
        btn.style.backgroundColor = preset.hex;
        btn.title = preset.name;
        btn.addEventListener("click", () => {
          if (isAdvancedMode && currentLimb) {
            applyColorToLimb(currentLimb, "fill", preset.hex);
          } else {
            applyGlobalColor("fill", preset.hex);
          }
        });
        container.appendChild(btn);
      });
    }

    function setupLimbSelector() {
      const container = document.getElementById("limbSelector");
      limbs.forEach(limb => {
        const btn = document.createElement("button");
        btn.className = "limb-btn";
        btn.textContent = limb.replace("_", " ");
        btn.addEventListener("click", () => {
          currentLimb = limb;
          isAdvancedMode = true;
          document.querySelectorAll(".limb-btn").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          document.getElementById("advancedColors").classList.remove("hidden");
          updateAdvancedColors();
        });
        container.appendChild(btn);
      });
    }

    function setupAccessories() {
      const container = document.getElementById("accessoriesGroup");
      accessories.forEach((acc, idx) => {
        const row = document.createElement("div");
        row.className = "toggle-row";
        
        const label = document.createElement("span");
        label.className = "toggle-label";
        label.textContent = acc;
        
        const toggle = document.createElement("div");
        toggle.className = "toggle-switch";
        if (state.accessories[acc]) {
          toggle.classList.add("active");
        }
        
        // Add event listener directly here
        toggle.addEventListener("click", () => {
          state.accessories[acc] = !state.accessories[acc];
          toggle.classList.toggle("active", state.accessories[acc]);
          updatePreview();
        });
        
        row.appendChild(label);
        row.appendChild(toggle);
        container.appendChild(row);
      });
    }

    function setupColorInputs() {
      // Global colors
      setupColorInput("globalFill", "globalFillHex", (val) => applyGlobalColor("fill", val));
      setupColorInput("globalStroke", "globalStrokeHex", (val) => applyGlobalColor("stroke", val));
      setupColorInput("globalStitch", "globalStitchHex", (val) => applyGlobalColor("stitch", val));
      
      // Advanced colors
      setupColorInput("advancedFill", "advancedFillHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "fill", val);
      });
      setupColorInput("advancedStroke", "advancedStrokeHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "stroke", val);
      });
      setupColorInput("advancedStitch", "advancedStitchHex", (val) => {
        if (currentLimb) applyColorToLimb(currentLimb, "stitch", val);
      });
    }

    function setupColorInput(colorId, hexId, callback) {
      const colorInput = document.getElementById(colorId);
      const hexInput = document.getElementById(hexId);
      
      colorInput.addEventListener("input", (e) => {
        const val = e.target.value.toUpperCase();
        hexInput.value = val;
        callback(val);
      });
      
      colorInput.addEventListener("change", (e) => {
        const val = e.target.value.toUpperCase();
        hexInput.value = val;
        callback(val);
      });
      
      hexInput.addEventListener("input", (e) => {
        let val = e.target.value.toUpperCase();
        if (!val.startsWith("#")) val = "#" + val;
        if (/^#[0-9A-F]{6}$/.test(val)) {
          colorInput.value = val;
          callback(val);
        }
      });
      
      hexInput.addEventListener("blur", (e) => {
        let val = e.target.value.toUpperCase();
        if (!val.startsWith("#")) val = "#" + val;
        if (!/^#[0-9A-F]{6}$/.test(val)) {
          val = colorInput.value;
          hexInput.value = val;
        }
      });
    }

    function setupToggles() {
      const stitchToggle = document.getElementById("stitchStyleToggle");
      stitchToggle.addEventListener("click", () => {
        state.stitch_hashed = !state.stitch_hashed;
        stitchToggle.classList.toggle("active", state.stitch_hashed);
        updatePreview();
      });
      
      // Animation selection
      const animDefault = document.getElementById("animDefault");
      const animWave = document.getElementById("animWave");
      
      function updateAnimationButtons() {
        animDefault.classList.toggle("active", state.animation === "Default");
        animWave.classList.toggle("active", state.animation === "Wave");
      }
      
      animDefault.addEventListener("click", () => {
        if (state.animation !== "Default") {
          state.animation = "Default";
          updateAnimationButtons();
          loadAndRenderAnimation();
        }
      });
      
      animWave.addEventListener("click", () => {
        if (state.animation !== "Wave") {
          state.animation = "Wave";
          updateAnimationButtons();
          loadAndRenderAnimation();
        }
      });
      
      updateAnimationButtons();
    }

    function setupButtons() {
      document.getElementById("previewBtn").addEventListener("click", () => {
        // Request preview from bot
        sendState("preview");
      });
      
      document.getElementById("doneBtn").addEventListener("click", () => {
        // Send final state and close
        sendState("done");
      });
    }

    function hexToRgba(hex) {
      hex = hex.replace("#", "");
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      return [r, g, b, 1];
    }

    function applyGlobalColor(kind, hex) {
      limbs.forEach(limb => {
        if (state.colors[limb][kind] !== undefined) {
          state.colors[limb][kind] = hex;
        }
      });
      updateGlobalColors();
      updatePreview();
    }

    function applyColorToLimb(limb, kind, hex) {
      if (state.colors[limb] && state.colors[limb][kind] !== undefined) {
        state.colors[limb][kind] = hex;
        updateAdvancedColors();
        updatePreview();
      }
    }

    function updateGlobalColors() {
      // Use first limb's colors as reference for global display
      const ref = state.colors.Head;
      document.getElementById("globalFill").value = ref.fill;
      document.getElementById("globalFillHex").value = ref.fill;
      document.getElementById("globalStroke").value = ref.stroke;
      document.getElementById("globalStrokeHex").value = ref.stroke;
      document.getElementById("globalStitch").value = ref.stitch;
      document.getElementById("globalStitchHex").value = ref.stitch;
    }

    function updateAdvancedColors() {
      if (!currentLimb) return;
      const colors = state.colors[currentLimb];
      document.getElementById("advancedFill").value = colors.fill || "#F1C799";
      document.getElementById("advancedFillHex").value = colors.fill || "#F1C799";
      document.getElementById("advancedStroke").value = colors.stroke || "#000000";
      document.getElementById("advancedStrokeHex").value = colors.stroke || "#000000";
      document.getElementById("advancedStitch").value = colors.stitch || "#000000";
      document.getElementById("advancedStitchHex").value = colors.stitch || "#000000";
    }

    function loadState(savedState) {
      if (savedState.colors) state.colors = savedState.colors;
      if (savedState.stitch_hashed !== undefined) state.stitch_hashed = savedState.stitch_hashed;
      // Handle legacy use_patch - migrate to TGpatch accessory
      if (savedState.use_patch !== undefined) {
        state.accessories.TGpatch = savedState.use_patch;
      }
      if (savedState.accessories) state.accessories = savedState.accessories;
      if (savedState.animation) {
        state.animation = savedState.animation;
        // Reload animation if it changed
        if (baseAnimationData) {
          loadAndRenderAnimation();
        }
      }
      
      // Update animation buttons if they exist
      if (document.getElementById("animDefault")) {
        const animDefault = document.getElementById("animDefault");
        const animWave = document.getElementById("animWave");
        animDefault.classList.toggle("active", state.animation === "Default");
        animWave.classList.toggle("active", state.animation === "Wave");
      }
      
      updateGlobalColors();
      document.getElementById("stitchStyleToggle").classList.toggle("active", state.stitch_hashed);
      
      accessories.forEach((acc, idx) => {
        const toggle = document.querySelectorAll("#accessoriesGroup .toggle-switch")[idx];
        if (toggle) {
        toggle.classList.toggle("active", state.accessories[acc]);
        }
      });
      
      // Update preview if animation is already loaded
      if (baseAnimationData) {
        updatePreview();
      }
    }

    async function loadAndRenderAnimation() {
      try {
        // Check if lottie is loaded
        if (typeof lottie === 'undefined') {
          throw new Error("Lottie library not loaded");
        }
        
        const animationFile = state.animation === "Wave" ? "RigletBase.json" : "RigletTurn.json";
        const url = `https://riglets.github.io/RigletsFrontEnd/${animationFile}`;
        
        console.log("Loading animation from:", url);
        document.getElementById("previewPlaceholder").textContent = "Loading animation...";
        
        const response = await fetch(url);
        console.log("Response status:", response.status, response.statusText);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const contentType = response.headers.get("content-type");
        console.log("Content-Type:", contentType);
        
        if (!contentType || !contentType.includes("application/json")) {
          console.warn("Warning: Content-Type is not JSON:", contentType);
        }
        
        const jsonData = await response.json();
        console.log("Animation loaded successfully, layers:", jsonData.layers?.length || 0);
        
        baseAnimationData = jsonData;
        updatePreview();
      } catch (error) {
        console.error("Error loading animation:", error);
        const errorMsg = error.message || "Unknown error";
        document.getElementById("previewPlaceholder").textContent = 
          `Failed to load preview: ${errorMsg}. Check console for details.`;
        
        // Show more helpful error message
        if (errorMsg.includes("404") || errorMsg.includes("Not Found")) {
          document.getElementById("previewPlaceholder").textContent = 
            "File not found. Make sure RigletTurn.json and RigletBase.json are in your GitHub Pages repo and accessible at: https://riglets.github.io/RigletsFrontEnd/";
        } else if (errorMsg.includes("CORS") || errorMsg.includes("Failed to fetch")) {
          document.getElementById("previewPlaceholder").textContent = 
            "Network error. Check if GitHub Pages is enabled and files are accessible.";
        } else if (errorMsg.includes("JSON")) {
          document.getElementById("previewPlaceholder").textContent = 
            "Invalid JSON file. Make sure the JSON files are valid.";
        }
      }
    }

    function applyColorsToAnimation(data, colors, stitchHashed) {
      // Deep clone the data to avoid modifying the original
      // Use the same approach as bot.py - load fresh JSON structure
      const animData = JSON.parse(JSON.stringify(data));
      
      console.log("Applying stitch_hashed:", stitchHashed);
      
      // Apply colors
      for (const layer of animData.layers || []) {
        const layerName = layer.nm;
        if (!RIGLET_GROUPS[layerName]) continue;
        
        const limbDef = RIGLET_GROUPS[layerName];
        const colorDef = colors[layerName] || {};
        
        for (const shape of layer.shapes || []) {
          if (!shape || shape.ty !== "gr") continue;
          
          const groupName = shape.nm;
          const targets = [];
          
          if (limbDef.fill && limbDef.fill.includes(groupName)) {
            const fillColor = colorDef.fill;
            if (fillColor) {
              targets.push({ kind: "fill", color: fillColor });
              console.log(`Found fill target: ${layerName}/${groupName} -> ${fillColor}`);
            }
          }
          
          if (limbDef.stroke && limbDef.stroke.includes(groupName)) {
            const strokeColor = colorDef.stroke;
            if (strokeColor) {
              targets.push({ kind: "stroke", color: strokeColor });
              console.log(`Found stroke target: ${layerName}/${groupName} -> ${strokeColor}`);
            }
          }
          
          if (limbDef.stitch && limbDef.stitch.includes(groupName)) {
            const stitchColor = colorDef.stitch;
            if (stitchColor) {
              targets.push({ kind: "stitch", color: stitchColor });
              console.log(`Found stitch target: ${layerName}/${groupName} -> ${stitchColor}`);
            }
          }
          
          if (targets.length === 0) continue; // Skip if no targets found
          
          console.log(`Processing ${targets.length} targets for ${layerName}/${groupName}`);
          
          for (const target of targets) {
            const rgba = hexToRgba(target.color);
            console.log(`  Target: ${target.kind}, color: ${target.color}, rgba:`, rgba);
            
            if (!shape.it || !Array.isArray(shape.it)) {
              console.log(`  No shape.it array found for ${layerName}/${groupName}`);
              continue;
            }
            
            console.log(`  Shape has ${shape.it.length} items`);
            
            for (const it of shape.it) {
              if (!it || !it.ty) continue;
              const ty = it.ty;
              
              if (ty === "fl" && target.kind === "fill") {
                console.log(`  Found fill element (fl) in ${layerName}/${groupName}`);
                if (it.c && it.c.k !== undefined && it.c.k !== null) {
                  console.log(`  Fill color structure:`, Array.isArray(it.c.k) ? `array[${it.c.k.length}]` : typeof it.c.k, it.c.k);
                  
                  // Extract RGB (first 3 values) from RGBA
                  const rgb = [rgba[0], rgba[1], rgba[2]];
                  
                  // Check if it's a static color array (RGB or RGBA)
                  if (Array.isArray(it.c.k) && (it.c.k.length === 3 || it.c.k.length === 4) && typeof it.c.k[0] === 'number') {
                    // Static RGB/RGBA array - replace with RGB (Lottie uses RGB for fills)
                    console.log(`  ✓ Applying fill color (RGB) to ${layerName}/${groupName}:`, rgb);
                    it.c.k = rgb;
                  } else if (Array.isArray(it.c.k) && it.c.k.length > 0) {
                    // Check if it's animated (keyframes)
                    const firstItem = it.c.k[0];
                    console.log(`  Fill is animated, first item:`, typeof firstItem, firstItem);
                    if (typeof firstItem === 'object' && firstItem.s !== undefined) {
                      // Animated with keyframes - modify the start/end values
                      console.log(`  ✓ Applying animated fill color (keyframes) to ${layerName}/${groupName}`);
                      it.c.k = it.c.k.map(kf => {
                        if (typeof kf === 'object' && kf.s !== undefined) {
                          // Keyframe with start/end values
                          const startRGB = Array.isArray(kf.s) && kf.s.length >= 3 ? kf.s.slice(0, 3) : rgb;
                          const endRGB = Array.isArray(kf.e) && kf.e.length >= 3 ? kf.e.slice(0, 3) : rgb;
                          return { ...kf, s: [rgb], e: [rgb] };
                        } else if (Array.isArray(kf) && (kf.length === 3 || kf.length === 4)) {
                          return rgb;
                        }
                        return kf;
                      });
                    } else if (typeof firstItem === 'number') {
                      // Array of numbers (RGB values) - this is the animated RGB array
                      console.log(`  ✓ Applying fill color (animated RGB array) to ${layerName}/${groupName}`);
                      it.c.k = rgb;
                    } else {
                      console.warn(`  ⚠ Unknown fill color structure for ${layerName}/${groupName}`);
                    }
                  } else {
                    console.warn(`  ⚠ Fill color structure not recognized:`, typeof it.c.k, it.c.k);
                  }
                } else {
                  console.warn(`  ⚠ No fill color property (it.c) found for ${layerName}/${groupName}`);
                }
              }
              
              if (ty === "st" && (target.kind === "stroke" || target.kind === "stitch")) {
                console.log(`  Found stroke element (st) in ${layerName}/${groupName}, kind: ${target.kind}`);
                if (it.c && it.c.k !== undefined && it.c.k !== null) {
                  console.log(`  Stroke color structure:`, Array.isArray(it.c.k) ? `array[${it.c.k.length}]` : typeof it.c.k, it.c.k);
                  
                  // Extract RGB (first 3 values) from RGBA
                  const rgb = [rgba[0], rgba[1], rgba[2]];
                  
                  // Check if it's a static color array (RGB or RGBA)
                  if (Array.isArray(it.c.k) && (it.c.k.length === 3 || it.c.k.length === 4) && typeof it.c.k[0] === 'number') {
                    // Static RGB/RGBA array - replace with RGB (Lottie uses RGB for strokes)
                    console.log(`  ✓ Applying ${target.kind} color (RGB) to ${layerName}/${groupName}:`, rgb);
                    it.c.k = rgb;
                  } else if (Array.isArray(it.c.k) && it.c.k.length > 0) {
                    // Check if it's animated (keyframes)
                    const firstItem = it.c.k[0];
                    console.log(`  Stroke is animated, first item:`, typeof firstItem, firstItem);
                    if (typeof firstItem === 'object' && firstItem.s !== undefined) {
                      // Animated with keyframes - modify the start/end values
                      console.log(`  ✓ Applying animated ${target.kind} color (keyframes) to ${layerName}/${groupName}`);
                      it.c.k = it.c.k.map(kf => {
                        if (typeof kf === 'object' && kf.s !== undefined) {
                          // Keyframe with start/end values
                          const startRGB = Array.isArray(kf.s) && kf.s.length >= 3 ? kf.s.slice(0, 3) : rgb;
                          const endRGB = Array.isArray(kf.e) && kf.e.length >= 3 ? kf.e.slice(0, 3) : rgb;
                          return { ...kf, s: [rgb], e: [rgb] };
                        } else if (Array.isArray(kf) && (kf.length === 3 || kf.length === 4)) {
                          return rgb;
                        }
                        return kf;
                      });
                    } else if (typeof firstItem === 'number') {
                      // Array of numbers (RGB values) - this is the animated RGB array
                      console.log(`  ✓ Applying ${target.kind} color (animated RGB array) to ${layerName}/${groupName}`);
                      it.c.k = rgb;
                    } else {
                      console.warn(`  ⚠ Unknown stroke color structure for ${layerName}/${groupName}`);
                    }
                  } else {
                    console.warn(`  ⚠ Stroke color structure not recognized:`, typeof it.c.k, it.c.k);
                  }
                } else {
                  console.warn(`  ⚠ No stroke color property (it.c) found for ${layerName}/${groupName}`);
                }
              
                // Process stitch dash - only for stroke elements (ty === "st")
                // Match bot.py structure exactly: it["d"] = [{"n": "d", "v": {"a": 0, "k": STITCH_DASH_LENGTH}}, {"n": "o", "v": {"a": 0, "k": 0}}]
                // The bot does: it["d"] = [...] directly, and it.pop("d", None) to remove
                // NOTE: Temporarily disabled - Lottie-web has issues with programmatically added dash arrays
                // The structure is correct but causes "Cannot redefine property: undefined" errors
                // Dash arrays will still work when sent to bot (bot creates file, not browser Lottie)
                if (target.kind === "stitch" && ty === "st" && false) {
                  if (stitchHashed) {
                    // Apply dash array - match bot.py exactly
                    // Bot does: it["d"] = [{"n": "d", "v": {"a": 0, "k": STITCH_DASH_LENGTH}}, {"n": "o", "v": {"a": 0, "k": 0}}]
                    it.d = [
                      { n: "d", v: { a: 0, k: STITCH_DASH_LENGTH } },
                      { n: "o", v: { a: 0, k: 0 } }
                    ];
                    console.log(`  ✓ Applied dash array to stitch ${layerName}/${groupName}`);
                  } else {
                    // Remove dash array - match bot.py: it.pop("d", None)
                    // In JavaScript, we use delete instead of pop
                    if (it.d !== undefined) {
                      delete it.d;
                      console.log(`  ✓ Removed dash array from stitch ${layerName}/${groupName}`);
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      // Apply accessories visibility
      for (const layer of animData.layers || []) {
        const layerName = layer.nm;
        for (const [accName, layerNames] of Object.entries(ACCESSORY_LAYERS)) {
          if (layerNames.includes(layerName)) {
            layer.hd = !state.accessories[accName];
          }
        }
      }
      
      // Apply patch visibility - remove TGpatch from Left_Leg if patch is off
      for (const layer of animData.layers || []) {
        if (layer.nm === "Left_Leg" && layer.shapes) {
          layer.shapes = layer.shapes.filter(shape => {
            if (shape.nm === "TGpatch" && !state.accessories.TGpatch) {
              return false; // Remove patch
            }
            return true; // Keep other shapes
          });
        }
      }
      
      // Re-serialize and parse to ensure clean structure (like bot.py writes to file then reads)
      // This ensures Lottie gets a completely fresh object without any internal references
      // The bot writes JSON to file then reads it, which gives a clean structure
      try {
        const serialized = JSON.stringify(animData);
        const cleaned = JSON.parse(serialized);
        console.log("Animation data cleaned and re-parsed (like bot.py file write/read)");
        return cleaned;
      } catch (e) {
        console.error("Error cleaning animation data:", e);
        return animData;
      }
    }

    function updatePreview() {
      if (!baseAnimationData) {
        console.log("No animation data available yet");
        return;
      }
      
      // Check if lottie is loaded
      if (typeof lottie === 'undefined') {
        console.error("Lottie library not available");
        document.getElementById("previewPlaceholder").textContent = "Lottie library not loaded";
        document.getElementById("previewPlaceholder").classList.remove("hidden");
        document.getElementById("lottieContainer").classList.add("hidden");
        return;
      }
      
      // Debounce updates for performance
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }
      
      updateTimeout = setTimeout(() => {
        try {
          console.log("Applying colors to animation...");
          const coloredData = applyColorsToAnimation(
            baseAnimationData,
            state.colors,
            state.stitch_hashed
          );
          
          console.log("Animation data processed, layers:", coloredData.layers?.length);
          
          // Clear the container first
          const container = document.getElementById("lottieContainer");
          container.innerHTML = '';
          
          // Destroy existing instance
          if (lottieInstance) {
            try {
              lottieInstance.destroy();
            } catch (e) {
              console.warn("Error destroying previous instance:", e);
            }
            lottieInstance = null;
          }
          
          // Destroy existing instance first
          if (lottieInstance) {
            try {
              lottieInstance.destroy();
            } catch (e) {
              console.warn("Error destroying previous instance:", e);
            }
            lottieInstance = null;
          }
          
          // Clear the container
          container.innerHTML = '';
          
          // Hide placeholder, show container
          const placeholder = document.getElementById("previewPlaceholder");
          placeholder.classList.add("hidden");
          container.classList.remove("hidden");
          
          // Ensure container is visible and has size
          console.log("Container dimensions:", container.offsetWidth, "x", container.offsetHeight);
          console.log("Container display:", window.getComputedStyle(container).display);
          console.log("Container visibility:", window.getComputedStyle(container).visibility);
          
          // Create new instance with updated data
          console.log("Rendering animation with Lottie...");
          console.log("Animation data keys:", Object.keys(coloredData));
          console.log("Animation width:", coloredData.w, "height:", coloredData.h);
          console.log("Animation frame rate:", coloredData.fr);
          console.log("Animation total frames:", coloredData.op);
          
          lottieInstance = lottie.loadAnimation({
            container: container,
            renderer: "svg",
            loop: true,
            autoplay: true,
            animationData: coloredData
          });
          
          // Set explicit size based on animation dimensions
          if (coloredData.w && coloredData.h) {
            const aspectRatio = coloredData.w / coloredData.h;
            const maxSize = 240; // Optimized for MiniApp display
            let width, height;
            if (aspectRatio > 1) {
              width = maxSize;
              height = maxSize / aspectRatio;
            } else {
              height = maxSize;
              width = maxSize * aspectRatio;
            }
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            console.log("Set container size to:", width, "x", height);
          }
          
          // Ensure animation plays
          if (lottieInstance) {
            lottieInstance.play();
            console.log("Forced animation to play");
          }
          
          // Add event listeners to check if animation loaded
          lottieInstance.addEventListener('data_ready', () => {
            console.log("Lottie animation data ready");
            console.log("Container after data ready:", container.innerHTML.length, "chars");
          });
          
          lottieInstance.addEventListener('DOMLoaded', () => {
            console.log("Lottie animation DOM loaded");
            console.log("Container has SVG:", container.querySelector('svg') !== null);
            const svg = container.querySelector('svg');
            if (svg) {
              console.log("SVG dimensions:", svg.offsetWidth, "x", svg.offsetHeight);
              console.log("SVG viewBox:", svg.getAttribute('viewBox'));
              console.log("SVG computed style:", window.getComputedStyle(svg).display);
              console.log("SVG computed visibility:", window.getComputedStyle(svg).visibility);
              
              // Force SVG to be visible
              svg.style.width = '100%';
              svg.style.height = '100%';
              svg.style.display = 'block';
              svg.style.visibility = 'visible';
            }
          });
          
          let errorLogged = false;
          lottieInstance.addEventListener('error', (error) => {
            if (!errorLogged) {
              errorLogged = true;
              console.error("Lottie animation error:", error);
              console.error("Error details:", error.nativeError);
              placeholder.classList.remove("hidden");
              container.classList.add("hidden");
              placeholder.textContent = 
                `Animation render error. Check console for details.`;
            }
          });
          
          console.log("Animation instance created");
          
          // Check after a short delay if SVG was created and get its properties
          setTimeout(() => {
            const svg = container.querySelector('svg');
            if (svg) {
              console.log("✓ SVG successfully rendered in container");
              console.log("SVG actual size:", svg.offsetWidth, "x", svg.offsetHeight);
              console.log("SVG client size:", svg.clientWidth, "x", svg.clientHeight);
              console.log("SVG bounding rect:", svg.getBoundingClientRect());
              console.log("SVG viewBox:", svg.getAttribute('viewBox'));
              console.log("SVG style:", svg.style.cssText);
              console.log("SVG computed width:", window.getComputedStyle(svg).width);
              console.log("SVG computed height:", window.getComputedStyle(svg).height);
              
              // Check if animation is playing
              if (lottieInstance) {
                console.log("Animation total frames:", lottieInstance.totalFrames);
                console.log("Animation current frame:", lottieInstance.currentFrame);
                console.log("Animation is playing:", !lottieInstance.isPaused);
                
                // Force play if paused
                if (lottieInstance.isPaused) {
                  console.log("Animation was paused, forcing play...");
                  lottieInstance.play();
                }
              }
              
              // Try to force visibility
              svg.style.width = '240px';
              svg.style.height = '240px';
              svg.style.display = 'block';
              svg.style.visibility = 'visible';
              svg.style.opacity = '1';
              
              // Check if SVG has any visible elements
              const paths = svg.querySelectorAll('path, circle, rect, ellipse, polygon');
              console.log("SVG has", paths.length, "drawable elements");
              if (paths.length > 0) {
                const firstPath = paths[0];
                console.log("First element fill:", window.getComputedStyle(firstPath).fill);
                console.log("First element stroke:", window.getComputedStyle(firstPath).stroke);
                console.log("First element opacity:", window.getComputedStyle(firstPath).opacity);
              }
            } else {
              console.warn("⚠ No SVG found in container after 500ms");
              console.log("Container HTML:", container.innerHTML.substring(0, 200));
            }
          }, 500);
        } catch (error) {
          console.error("Error updating preview:", error);
          document.getElementById("previewPlaceholder").classList.remove("hidden");
          document.getElementById("lottieContainer").classList.add("hidden");
          document.getElementById("previewPlaceholder").textContent = 
            `Error rendering preview: ${error.message}`;
        }
      }, 100); // 100ms debounce for smooth updates
    }

    function sendState(action) {
      const data = {
        action: action,
        colors: state.colors,
        stitch_hashed: state.stitch_hashed,
        use_patch: state.accessories.TGpatch, // Map TGpatch to use_patch for bot compatibility
        accessories: state.accessories,
        animation: state.animation
      };
      
      if (tg) {
      tg.sendData(JSON.stringify(data));
      
      if (action === "done") {
        tg.close();
        }
      } else {
        console.error("Telegram WebApp not available, cannot send data");
      }
    }

    // Wait for DOM and scripts to load
    function startApp() {
      console.log("Starting app initialization...");
      console.log("Lottie available:", typeof lottie !== 'undefined');
      console.log("Telegram WebApp available:", tg !== null && tg !== undefined, tg);
      
      if (typeof lottie === 'undefined') {
        console.warn("Lottie not loaded yet, waiting...");
        document.getElementById("previewPlaceholder").textContent = "Loading Lottie library...";
        
        // Check every 100ms for lottie
        const checkLottie = setInterval(() => {
          if (typeof lottie !== 'undefined') {
            clearInterval(checkLottie);
            console.log("Lottie loaded, initializing app...");
    init();
          }
        }, 100);
        
        // Give up after 5 seconds
        setTimeout(() => {
          if (typeof lottie === 'undefined') {
            clearInterval(checkLottie);
            console.error("Lottie library failed to load after 5 seconds");
            document.getElementById("previewPlaceholder").textContent = 
              "Failed to load Lottie library. Please check your internet connection.";
          }
        }, 5000);
      } else {
        console.log("Lottie already loaded, initializing immediately...");
        init();
      }
    }
    
    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', startApp);
    } else {
      // DOM already loaded
      startApp();
    }
    
    // Also try on window load as backup (but only if not already initialized)
    window.addEventListener('load', () => {
      if (!isInitialized && typeof lottie !== 'undefined') {
        console.log("Window loaded, checking if we need to initialize...");
        if (!baseAnimationData) {
          console.log("Initializing from window load event...");
          init();
        }
      }
    });
  </script>
</body>
</html>

